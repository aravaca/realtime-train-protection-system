<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TASC Simulator</title>
  <!-- Google Fonts: Noto Sans JP Bold -->
  <link href="https://fonts.cdnfonts.com/css/a-otf-shin-go-pro" rel="stylesheet">
<style>
@import url('https://fonts.cdnfonts.com/css/a-otf-shin-go-pro');

html, body {
  margin: 0;
  background: radial-gradient(circle at 50% 20%, #0b0f14, #05070a);
  background-attachment: fixed;
  color: #e7f0ff;
  font-family: 'Orbitron', system-ui, Segoe UI, Roboto, Apple SD Gothic Neo, AppleGothic, sans-serif;
}
.game-background,.snow-background,.rain-background{background:transparent!important}
#wrap{max-width:960px;margin:18px auto;padding:0 12px}
.row{display:flex;gap:12px;align-items:center}
.card{
  background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.15);border-radius:16px;padding:16px;
  backdrop-filter:blur(10px);box-shadow:0 8px 24px rgba(0,0,0,.5);transition:transform .2s,box-shadow .2s
}
.card:hover{transform:translateY(-2px);box-shadow:0 12px 28px rgba(0,0,0,.7)}
canvas{width:100%;height:320px;background:linear-gradient(#0b0f14,#0a1019);border-radius:12px}
.kbd{background:rgba(10,18,28,.8);border:1px solid #2b3f5f;color:#9fc5ff;padding:2px 6px;border-radius:6px;font-size:12px}
.stat{font-size:32px;font-weight:800;color:#fff;text-shadow:0 0 4px rgba(0,200,255,.8)}
.ok{color:#9effb5}.warn{color:#ffd18f}.bad{color:#ff9b9b}
button,.btn-primary{background:linear-gradient(135deg,#00c6ff,#0072ff);color:#fff;border:none;border-radius:12px;padding:10px 16px;font-size:15px;font-weight:600;transition:.3s background,.1s transform}
button:hover,.btn-primary:hover{background:linear-gradient(135deg,#0072ff,#00c6ff);transform:translateY(-1px)}
#overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,.6);
  backdrop-filter: blur(8px);
  z-index: 9999;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

/* ğŸ’» ë°ìŠ¤í¬íƒ‘ ì „ìš© (768px ì´ˆê³¼ ì‹œ) */
@media (min-width: 769px) {
  #overlay {
    inset: auto;       /* ì „ì²´ ë®ëŠ” ëŒ€ì‹  */
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;

    justify-content: center;
    align-items: flex-start;
    padding-top: 40px; /* ì‚´ì§ ì—¬ë°± */
  }
  #overlay .card {
    width: 720px;      /* ì›í•˜ëŠ” fixed width */
    max-height: 90vh;  /* ì„¸ë¡œëŠ” ìŠ¤í¬ë¡¤ í—ˆìš© */
  }
}

#overlay.hide{display:none}
#overlay .card{max-height:90vh;overflow-y:auto}
.title{font-size:1.4rem;font-weight:600;margin-bottom:4px;color:#00f6ff}
.subtitle{font-size:.9rem;color:#9fc5ff;margin-bottom:16px}
.form-label{display:block;font-size:.85rem;margin-bottom:12px;text-align:left;font-weight:500;color:#cceaff}
.form-input{width:100%;box-sizing:border-box;padding:8px 10px;font-size:.9rem;border:1px solid rgba(0,246,255,.3);border-radius:8px;margin-top:4px;background:rgba(10,18,28,.6);color:#e7f0ff}
.form-input:focus{border-color:#00f6ff;outline:none}
@keyframes snow{0%{transform:translateY(-20px)}100%{transform:translateY(100vh)}}
.snowflakes,.raindrops{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;display:none;overflow:hidden}
.snowflakes div{position:absolute;background:#fff;width:10px;height:10px;border-radius:50%;opacity:.8;animation:snow 5s linear infinite}
.raindrops{z-index:9998}
.raindrops div{position:absolute;background:rgba(173,216,230,.8);width:2px;height:15px;animation:rain .5s linear infinite}
@keyframes rain{0%{transform:translateY(-20px)}100%{transform:translateY(100vh)}}
body{overflow-x:hidden;overflow-y:auto}
@media (max-width:768px){html,body{height:100%}body{-webkit-overflow-scrolling:touch}#wrap{padding-bottom:96px}canvas#hud{height:42vh}}
/* ì¬ì‹œì‘ FAB â€“ ìµœìƒë‹¨, í´ë¦­ í™•ì‹¤í•˜ê²Œ */
.fab{
  position:fixed;left:50%;bottom:24px;transform:translateX(-50%);padding:12px 18px;font-weight:700;border-radius:999px;
  background:linear-gradient(135deg,#00c6ff,#0072ff);color:#fff;border:none;z-index:10001;
  box-shadow:0 8px 24px rgba(0,0,0,.35);cursor:pointer;pointer-events:auto
}
.fab.hide{display:none}
.fab:hover{background:linear-gradient(135deg,#0072ff,#00c6ff);transform:translateX(-50%) translateY(-1px)}
.mobile-control-guide{display:none;font-size:14px;color:#9fc5ff;background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.2);padding:8px 12px;border-radius:8px;margin-bottom:12px}
@media (max-width:768px){.mobile-control-guide{display:block}}
/* TASC í† ê¸€ â€“ ì‚´ì§ ì•„ë˜ */
.tasc-toggle {
  position: absolute;
  right: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
  font-family: 'Orbitron', sans-serif;
  z-index: 1001;
  top: 40px;
}
@media (max-width: 768px) {.tasc-toggle {top: 165px;}}
.tasc-toggle .tasc-label{font-size:12px;font-weight:600;color:#9fc5ff;user-select:none}
.tasc-toggle input{display:none}
.tasc-toggle .slider{position:relative;display:inline-block;width:46px;height:24px;background:rgba(255,255,255,.25);border-radius:24px;cursor:pointer;transition:background-color .3s;box-shadow:inset 0 0 4px rgba(0,0,0,.3)}
.tasc-toggle .slider::before{content:"";position:absolute;height:18px;width:18px;left:3px;bottom:3px;background:#fff;border-radius:50%;transition:transform .3s;box-shadow:0 1px 3px rgba(0,0,0,.4)}
.tasc-toggle input:checked + .slider{background:linear-gradient(135deg,#00c6ff,#0072ff)}
.tasc-toggle input:checked + .slider::before{transform:translateX(22px)}

.emoji { width: 1.4em; height: 1.4em; vertical-align: middle; transition: transform 0.2s;}
.emoji:hover { transform: scale(1.3);}

.title { font-size: 1.7em; font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal; font-weight: 700; color: #0168B7; display: flex; align-items: center; gap: 8px;}

.line {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin: 4px 0;
}
.line .value {
  text-align: right;
  padding-right: 40px;  /* ğŸ‘ˆ ì˜¤ë¥¸ìª½ì— ì—¬ë°± ì£¼ê¸° (ë¼ë”ìº”ë²„ìŠ¤+ê°„ê²©) */
  min-width: 100px;     /* ğŸ‘ˆ ìˆ«ì ì¹¸ ìµœì†Œ ë„ˆë¹„ ì¡ì•„ì£¼ë©´ ë” ì•ˆì •ì  */
}
.line .unit {
  margin-left: 4px;
  opacity: 0.8;
  font-size: 14px;
  letter-spacing:-2px;
}

#timer {
  letter-spacing: 0px; /* ìˆ«ì ê°„ê²© ì•½ê°„ ë„“íˆê¸° */
}

@media (max-width:768px){
  .line .value { padding-right: 50px; }
}
</style>
</head>
<body>
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">

 <!--   <div class="mobile-control-guide" id="mobileGuide">
      ğŸ“± <b>ëª¨ë°”ì¼ ì¡°ì‘ ì•ˆë‚´:</b> ìº”ë²„ìŠ¤(ê·¸ë˜í”„) ìœ„ë¥¼ í„°ì¹˜í•˜ì„¸ìš”.<br>
      ìœ„ìª½ í„°ì¹˜ â†’ ë¸Œë ˆì´í¬ ê°•í™” ğŸ”¼ / ì•„ë˜ìª½ í„°ì¹˜ â†’ ì™„í™” ğŸ”½<br>
      ì •ì°¨ í›„ ì•„ë˜ í™”ë©´ì—ì„œ í”¼ë“œë°±ì„ í™•ì¸í•˜ì„¸ìš”.
    </div> -->

<div class="card" style="flex:1 1 260px; position: relative">
  <div id="carName" style="font-size:20px; font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal;" class="stat">ì°¨ëŸ‰ ë¡œë”© ì¤‘...</div>

 <div class="line">
  <span id="labelRemainTime">ë‚¨ì€ì‹œê°„</span>
  <span class="stat value" id="timer">0 s</span>
</div>
<div class="line">
  <span id="labelSpeed">ì†ë„</span>
  <span class="stat value"><span id="spd">â€”</span><span class="unit"> km/h</span></span>
</div>
<div class="line">
  <span id="labelRemainDist">ì •ì°¨</span>
  <span class="stat value" id="rem">â€”</span>
</div>
<div class="line">
  <span id="labelGrade">êµ¬ë°°</span>
  <span class="stat value"><span id="grade_percent">â€”</span><span class="unit"> â€°</span></span>
</div>
<div class="line">
  <span id="labelNotch">ì œë™</span>
  <span class="stat value" id="notch">-</span>
</div>
  <div style="margin-top:8px">
    <span id="labelControls">ì¡°ì‘:</span>
    <span class="kbd">Space</span> <span id="labelStartKey">ì‹œì‘</span> Â·
    <span class="kbd">W</span> <span id="labelUp">ê°•í™”</span> Â·
    <span class="kbd">S</span> <span id="labelDown">ì™„í™”</span> Â·
    <span class="kbd">N</span> <span id="labelRelease">í•´ë°©</span>
  </div>

  <canvas id="brakeLadder" style="position:absolute; right:10px; top:30px; width:28px; height:70%;"></canvas>
</div>

<div class="card" style="flex:2 1 520px"><canvas id="hud"></canvas></div>
<div class="card" style="flex:1 1 240px"><div><b>í”¼ë“œë°±</b></div><div id="fb">Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.</div></div>
</div>
</div>

<!-- ì˜¤ë²„ë ˆì´ -->
<div id="overlay">
  <div class="card">
    <h2 class="title">
      <img src="./Screenshot_20250815_220422_Brave(1).png" alt="E233" class="emoji"> 
      JR TASC Simulator
    </h2>

    <p class="subtitle" id="subtitleIntro">ì´ˆê¸°ê°’ ì…ë ¥ í›„ <b>TASC(ìë™ì •ì°¨)</b> ì„¤ì •í•˜ê³  <b>Space</b> ë˜ëŠ” ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ì‹œì‘í•˜ì„¸ìš”. TASCê°€ í™œì„±í™”ëœ ìƒíƒœì—ì„œë„, ìš´ì „ìëŠ” ìˆ˜ë™ ì¡°ì‘ìœ¼ë¡œ ìš´ì „ì— ê°œì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

    <!-- TASC -->
    <div class="tasc-toggle">
      <input type="checkbox" id="tascToggle" />
      <label for="tascToggle" class="slider"></label>
      <span class="tasc-label" id="labelTASC" style="font-weight:700">TASC</span>
    </div>

    <!-- ì „ë™ì°¨ / ì‹œë¦¬ì¦ˆ -->
    <label class="form-label"><span id="labelTrain">ì „ë™ì°¨</span>
      <select id="trainFamily" class="form-input">
        <option value="E233" selected>E233ê³„</option>
        <option value="E235">E235ê³„</option>
        <option value="JRW223">223ê³„</option>
        <option value="JRW225">225ê³„</option>
        <option value="JRH261">261ê³„</option>
        <option value="JRW285">285ê³„</option>
        <option value="JRW323">323ê³„</option>
        <option value="JR103">103ê³„</option>
        <option value="EF510">EF510í˜• ì „ê¸°ê¸°ê´€ì°¨ + E26ê³„ ê°ì°¨</option>
        <option value="K3000">ì¼€ì´ì„¸ì´ 3000ê³„</option>
        <option value="T5300">ë„ì¿„ë„ êµí†µêµ­ 5300ê³„</option>
      </select>
    </label>
    <label class="form-label"><span id="labelSeries">ì‹œë¦¬ì¦ˆ</span>
      <select id="trainSeries" class="form-input"></select>
    </label>

    <!-- âœ… ì†ë„/ê±°ë¦¬ ì…ë ¥ ë²”ìœ„ ê°±ì‹ : ì†ë„ 40~130, ê±°ë¦¬ 150~900 -->
    <label class="form-label"><span id="labelInitSpeed">ì´ˆê¸° ì†ë„ (km/h)</span>
      <input id="inputSpeed" type="number" value="70" min="40" max="130" step="1" class="form-input">
    </label>
    <label class="form-label"><span id="labelInitDist">ê±°ë¦¬ (m)</span>
      <input id="inputDist" type="number" value="300" min="150" max="900" step="1" class="form-input">
    </label>
    <label class="form-label"><span id="labelGradeInput">ê²½ì‚¬ë„ (â€°)</span>
      <input id="inputGrade" type="number" value="0.0" min="-10" max="10" step="0.1" class="form-input">
    </label>

    <label class="form-label"><span id="labelWeather">ë‚ ì”¨</span>
      <select id="weatherSelect" class="form-input">
        <option value="ë§‘ìŒ">ë§‘ìŒ</option><option value="ë¹„ì˜´">ìš°ì²œ</option><option value="ëˆˆì˜´">ê°•ì„¤/ë¹™íŒ</option>
      </select>
    </label>
    <label class="form-label"><span id="labelLoadRate">ìŠ¹ê° íƒ‘ìŠ¹ë¥  (%)</span>
      <input id="inputLoadRate" type="number" value="70" min="0" max="120" step="1" class="form-input">
    </label>

    <!-- í¸ì„± (ì‹œë¦¬ì¦ˆë³„ë¡œë§Œ ê³ ì • ë…¸ì¶œ) -->
    <label class="form-label"><span id="labelTrainLength">í¸ì„±</span>
      <select class="form-input" id="trainLength" onchange="updateTrainLength()"></select>
    </label>

    <div class="game-background"></div>
    <div class="snowflakes"></div>
    <div class="raindrops">
      <div style="animation-delay:0s;left:5%"></div><div style="animation-delay:.2s;left:15%"></div>
      <div style="animation-delay:.4s;left:25%"></div><div style="animation-delay:.6s;left:35%"></div>
      <div style="animation-delay:.8s;left:45%"></div><div style="animation-delay:1s;left:55%"></div>
      <div style="animation-delay:1.2s;left:65%"></div><div style="animation-delay:1.4s;left:75%"></div>
      <div style="animation-delay:1.6s;left:85%"></div><div style="animation-delay:1.8s;left:95%"></div>
    </div>

    <div class="kbd-info"><span class="kbd">W</span> ê°•í™” Â· <span class="kbd">S</span> ì™„í™” Â· <span class="kbd">N</span> í•´ë°©</div>
    <button id="btnStart" class="btn-primary" type="button" style="margin-top:8px">Start (Space)</button>
  </div>
</div>

<!-- ì¬ì‹œì‘ FAB -->
<button id="btnMobileRestart" class="fab hide" type="button">ì¬ì‹œì‘</button>

<script>
/* ===== WebSocket & TASC ===== */
const ws = new WebSocket((location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws");

ws.addEventListener('open', () => {
  // âœ… ë³´ì •í‘œ(IDW) í•œ ë²ˆë§Œ ì„¸íŒ…í•˜ë©´ ì´í›„ ìë™ ì œí•œì‹œê°„ ì‚°ì¶œ
  ws.send(JSON.stringify({
    type: "cmd",
    payload: {
      name: "setTimerCalib",
      points: [
        { v: 40, L: 150, t: 27 },
        { v: 60, L: 200, t: 29 },
        { v: 70, L: 300, t: 32 },
        { v: 90, L: 500, t: 40 },
        { v: 130, L: 900, t: 49 }
      ],
      norm_v: 100,
      norm_L: 300,
      idw_power: 2.0,
      blend_threshold: 1.5
    }
  }));
  // íƒ€ì´ë¨¸ í™œì„±í™”
  ws.send(JSON.stringify({ type: "cmd", payload: { name: "toggleTimer", enabled: true } }));
});

const tascToggle = document.getElementById("tascToggle");
tascToggle.addEventListener("change", () => {
  const enabled = tascToggle.checked;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled } }));
  }
});
// function forceManualOverride(){
//   if (tascToggle.checked){
//     tascToggle.checked=false;
//     if (ws.readyState===WebSocket.OPEN){
//       ws.send(JSON.stringify({type:"cmd",payload:{name:"setTASC",enabled:false}}));
//     }
//   }
// }

/* ===== ë‚ ì”¨ ì´í™íŠ¸ ===== */
const snowflakesContainer=document.querySelector('.snowflakes');
function generateSnowflake(){
  const s=document.createElement('div');
  s.style.animationDelay=(Math.random()*2)+'s';
  s.style.animationDuration=(Math.random()*5+5)+'s';
  s.style.left=Math.floor(Math.random()*101)+'%';
  s.style.position='absolute';s.style.top='-10px';s.style.width='10px';s.style.height='10px';s.style.backgroundColor='rgba(255,255,255,.8)';s.style.borderRadius='50%';
  snowflakesContainer.appendChild(s);
  setTimeout(()=>snowflakesContainer.removeChild(s),7000);
}
setInterval(generateSnowflake,200);

/* ===== Haptics (ëª¨ë°”ì¼) ===== */
const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
function canVibrate() { return isMobile && typeof navigator.vibrate === "function" && document.visibilityState === "visible"; }
function vibrate(pattern) { if (!canVibrate()) return false; return navigator.vibrate(pattern) !== false; }
function hapticForNotch(delta) { if (delta !== 0) vibrate([80, 10, 80]); }
function hapticForEB() { vibrate([80, 100, 80]); }

/* ===== ì°¨ëŸ‰ JSON ë¡œë“œ (ìºì‹œ ë¬´ì‹œ) ===== */
let vehicle=null; let brakeDecels={};
const cacheBust=()=>`?v=${Date.now()}`;
fetch('./e233_1000.json'+cacheBust(),{cache:'no-store'})
  .then(r=>r.json()).then(data=>{
    vehicle=data; document.getElementById('carName').textContent=vehicle.name;
    if(vehicle.notch_accels && vehicle.notches){
      brakeDecels={}; for(let i=0;i<vehicle.notches;i++){ brakeDecels[i]=Math.abs(vehicle.notch_accels[vehicle.notches-1-i]??0); }
    }
  }).catch(console.error);

/* ===== DOM ===== */
const remEl=document.getElementById("rem"),
      spdEl=document.getElementById("spd"),
      notchEl=document.getElementById("notch"),
      fb=document.getElementById("fb"),
      timerEl=document.getElementById("timer");
const overlay=document.getElementById("overlay"),
      btnStart=document.getElementById("btnStart"),
      canvas=document.getElementById("hud"),
      ctx=canvas.getContext("2d");
const weatherSelect=document.getElementById("weatherSelect"),
      snowflakes=document.querySelector(".snowflakes"),
      raindrops=document.querySelector(".raindrops");

function resize(){ canvas.width=canvas.clientWidth*devicePixelRatio; canvas.height=canvas.clientHeight*devicePixelRatio; } 
addEventListener("resize",resize); resize();

function getEbIdx(){
  const acc = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const n   = acc ? acc.length : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);
  return Math.max(1, n - 1); // 0:N, 1..EB-1:B..., EB:ë§ˆì§€ë§‰
}
function sendCmd(name, delta){
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
  }
}

/* ===== í¸ì„± & íƒ‘ìŠ¹ë¥  ===== */
function updateTrainLength(){ const L=document.getElementById("trainLength").value; ws.send(JSON.stringify({type:"cmd",payload:{name:"setTrainLength",length:L}})); sendLoadRate(); }
function sendLoadRate(){
  const loadRate=parseFloat(document.getElementById("inputLoadRate").value)||0;
  const trainLength=parseInt(document.getElementById("trainLength").value)||8;
  ws.send(JSON.stringify({ type: "cmd", payload: { name: "setLoadRate", loadRate, length: trainLength }}));
}

/* ===== ì…ë ¥ ë³´ì • & ì œí•œ ===== */
const inputSpeed=document.getElementById("inputSpeed"),
      inputDist=document.getElementById("inputDist"),
      inputGrade=document.getElementById("inputGrade"),
      inputLoadRate=document.getElementById("inputLoadRate");

const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
function enforceInt(el,min,max){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^\d-]/g,'');}); el.addEventListener('change',()=>{let v=parseInt(el.value,10); if(isNaN(v)){el.value='';return;} el.value=String(clamp(v,min,max));});}
function enforceFloat(el,min,max,d=1){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^0-9.\-]/g,'');}); el.addEventListener('change',()=>{let v=parseFloat(el.value); if(isNaN(v)){el.value='';return;} v=clamp(v,min,max); el.value=v.toFixed(d);});}

/* âœ… ë²”ìœ„ ê°±ì‹ : ì†ë„ 40~130 / ê±°ë¦¬ 150~900 */
enforceInt(inputSpeed,40,130);
enforceInt(inputDist,150,900);
enforceInt(inputLoadRate,0,120);
enforceFloat(inputGrade,-10,10,1);

/* âœ… ì†ë„ë³„ ìµœì†Œ ê±°ë¦¬ ê·œì¹™ */
function minDistForSpeed(v) {
  if (v >= 130) return 900;
  if (v >= 120) return 900;
  if (v >= 110) return 800;
  if (v >= 100) return 600;
  if (v >= 90)  return 500;
  if (v >= 80)  return 400;
  if (v >= 70)  return 300;
  if (v >= 60)  return 250;
  if (v >= 50)  return 200;
  return 150; // v >= 40
}
function showHint(msg) {
  fb.innerHTML = `<div class="warn">${msg}</div>`;
  setTimeout(() => {
    if (!st || !st.finished) fb.textContent = "Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.";
  }, 1200);
}
function applySpeedDistanceRule() {
  let v = Number(inputSpeed.value || 0);
  v = Math.min(130, Math.max(40, v));
  const requiredMin = minDistForSpeed(v);
  let d = Number(inputDist.value || 0);
  const absoluteMin = 150, absoluteMax = 900;
  const newMin = Math.max(absoluteMin, requiredMin);

  inputDist.min = String(newMin);

  if (isNaN(d) || d < newMin) {
    inputDist.value = String(newMin);
    showHint(`ì†ë„ ${v} km/hì—ì„œëŠ” ìµœì†Œ ê±°ë¦¬ ${newMin} m ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.`);
  } else if (d > absoluteMax) {
    inputDist.value = String(absoluteMax);
  }
}
inputSpeed.addEventListener('change', applySpeedDistanceRule);
inputSpeed.addEventListener('input',  () => {
  const v = Number(inputSpeed.value || 0);
  const minD = minDistForSpeed(Math.min(130, Math.max(40, v)));
  inputDist.min = Math.max(150, minD);
});

/* ===== ë‚ ì”¨ UI ===== */
function muFromWeather(w){return w==="ë¹„ì˜´"?0.6:(w==="ëˆˆì˜´"?0.3:1.0)}
function updateWeatherUI(){
  const w=weatherSelect.value, ov=document.getElementById("overlay");
  if(w==="ëˆˆì˜´"){snowflakes.style.display="block";raindrops.style.display="none";document.documentElement.style.background="#fff";document.body.style.background="#fff";ov.style.background="rgba(255,255,255,.15)";canvas.style.background="#fff";}
  else if(w==="ë¹„ì˜´"){snowflakes.style.display="none";raindrops.style.display="block";document.documentElement.style.background="#4b5d67";document.body.style.background="#4b5d67";ov.style.background="rgba(40,60,80,.35)";canvas.style.background="#4b5d67";}
  else{snowflakes.style.display="none";raindrops.style.display="none";const g="radial-gradient(circle at 50% 20%, #0b0f14, #05070a)";document.documentElement.style.background=g;document.body.style.background=g;ov.style.background="rgba(0,0,0,.6)";canvas.style.background="linear-gradient(#0b0f14,#0a1019)";}
}
weatherSelect.addEventListener("change",()=>{updateWeatherUI();const mu=muFromWeather(weatherSelect.value); if(ws.readyState===WebSocket.OPEN){ws.send(JSON.stringify({type:"cmd",payload:{name:"setMu",value:mu}}));}});
updateWeatherUI();

/* ===== ì‹œì‘/ì¬ì‹œì‘ ===== */
function startRun(){
  inputSpeed.dispatchEvent(new Event('change'));
  inputDist.dispatchEvent(new Event('change'));
  inputGrade.dispatchEvent(new Event('change'));

  applySpeedDistanceRule();

  const speed=Number(inputSpeed.value),
        dist=Number(inputDist.value),
        grade=Number(inputGrade.value),
        mu=muFromWeather(weatherSelect.value);

  if(ws.readyState===WebSocket.OPEN){
    ws.send(JSON.stringify({ type:"cmd", payload:{ name:"toggleTimer", enabled:true }}));
    ws.send(JSON.stringify({type:"cmd",payload:{name:"setInitial",speed,dist,grade,mu}}));
    ws.send(JSON.stringify({type:"cmd",payload:{name:"start"}}));
  }
  overlay.classList.add("hide"); isFinished=false; overlayShowingResult=false;
  btnMobileRestart.classList.add("hide");
}
btnStart.addEventListener("click", startRun);

/* ì¬ì‹œì‘ FAB */
const btnMobileRestart=document.getElementById("btnMobileRestart");
btnMobileRestart.addEventListener("click", ()=>{
  if(!overlay.classList.contains("hide")) overlay.classList.add("hide");
  overlay.classList.remove("hide");
  overlayShowingResult=true;
  btnMobileRestart.classList.add("hide");
});

/* ===== ëª¨ë°”ì¼ í„°ì¹˜ ì¡°ì‘ ===== */
if(/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)){
  const game=document.getElementById("hud");
  game.addEventListener("touchstart",(e)=>{
    if(!overlay.classList.contains("hide")) return;
    if(e.touches.length!==1) return;
    // forceManualOverride();
    const r=game.getBoundingClientRect(), y=e.touches[0].clientY-r.top, half=r.height/2;
    if(y<half){ hapticForNotch(+1); sendCmd("applyNotch",+1); }
    else      { hapticForNotch(-1); sendCmd("applyNotch",-1); }
  }, { passive: true });
}

/* ===== í‚¤ë³´ë“œ ===== */
addEventListener("keydown", (e) => {
  if([" ","w","W","s","S","n","N","e","E","d","D", "a", "A"].includes(e.key)) e.preventDefault();
  if(e.repeat) return;

  if(e.key === " "){ 
    if(ws.readyState !== WebSocket.OPEN) return; 
    startRun(); 
  }
  else if(e.key === "w" || e.key === "W"){ 
    sendCmd("applyNotch", +1); 
  }
  else if(e.key === "s" || e.key === "S"){ 
    sendCmd("applyNotch", -1); 
  }
  else if(e.key === "n" || e.key === "N"){ 
    sendCmd("release", 0); 
  }
  else if(e.key === "e" || e.key === "E"){ 
    sendCmd("emergencyBrake", 0);  
  }
  else if(e.key === "d" || e.key === "D"){ 
    // ì œë™ 1ë‹¨
    sendCmd("setNotch", 1);  
  }
  else if(e.key === "a" || e.key === "A"){
    if(vehicle && vehicle.notches){
      sendCmd("setNotch", vehicle.notches - 2); // EB ì§ì „ notch
    }
  }

});

/* ===== HUD & ìƒíƒœ ===== */
const grade_percentEl=document.getElementById("grade_percent");
let isFinished=false, overlayShowingResult=false, st=null, lastTimestamp=0, prevMaxDistance=0;
function loop(ts){ if(!lastTimestamp) lastTimestamp=ts; lastTimestamp=ts; if(st) drawHUD(st); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

// í—¬í¼: ì •ìˆ˜ë¥¼ MM:SS í˜•ì‹ìœ¼ë¡œ ë°”ê¾¸ê¸°
function formatTimeSec(secInt) {
  const sign = secInt < 0 ? "+" : "";
  const s = Math.abs(secInt);
  const m = Math.floor(s / 60);
  const s2 = s % 60;
  return sign
    + (m < 10 ? "0" : "") + m + ": "   // ì½œë¡  ì•ë’¤ì— ê³µë°± ì¶”ê°€
    + (s2 < 10 ? "0" : "") + s2;
}

// ===== WebSocket (ë‹¨ì¼ í•¸ë“¤ëŸ¬ë¡œ êµì²´) =====
ws.onmessage = (ev) => {
  const msg = JSON.parse(ev.data);
  if (msg.type !== "state") return;

  // ìƒíƒœ ì €ì¥
  st = msg.payload;
  window.st = st;

  // ìˆ«ì HUD ê°±ì‹ 
  const remRaw = st.remaining_m;
  const rem = (typeof remRaw === "number") ? remRaw : parseFloat(remRaw);
  // ê±°ë¦¬ í‘œì‹œ
if (rem >= 0) {
  if (rem <= 2)  remEl.textContent = Math.round(rem * 100) + " cm";
  else           remEl.textContent = rem.toFixed(0) + " m";
} else {
  if (rem >= -2) remEl.textContent = "-" + Math.round(Math.abs(rem) * 100) + " cm";
  else           remEl.textContent = "-" + Math.abs(rem).toFixed(0) + " m";
}

// âœ… ìƒ‰ìƒ ì¡°ê±´ ì ìš© (Â±0.35m ì´ë‚´ë©´ ì´ˆë¡ìƒ‰, ì•„ë‹ˆë©´ ê¸°ë³¸)
if (Math.abs(rem) <= 0.35) {
  remEl.style.color = "#9effb5";   // ì´ˆë¡
} else {
  remEl.style.color = "";          // ê¸°ë³¸ (.statì˜ í•˜ì–€ìƒ‰ìœ¼ë¡œ ë³µê·€)
}

  spdEl.textContent = (st.v * 3.6).toFixed(1);


  const maxIdx = (vehicle?.notches ?? 10) - 1; // EB ì¸ë±ìŠ¤
let notchText = "N";
let notchColor = "";

if (st.lever_notch === 0) {
  notchText = "N";
  notchColor = "#9effb5";     // ì´ˆë¡
} else if (st.lever_notch === maxIdx) {
  notchText = "EB";
  notchColor = "#ff5757";     // ë¹¨ê°•
} else {
  notchText = `B${st.lever_notch}`;
  notchColor = "#ed9a09";     // ì–´ë‘ìš´ ì£¼í™©/í™©í† ìƒ‰
}

notchEl.textContent = notchText;
notchEl.style.color = notchColor;




  grade_percentEl.textContent = (10 * st.grade_percent).toFixed(1);



  const running  = !!st.running;
  const finished = !!st.finished;
  const budget   = Number(st.time_budget_s ?? 0);
  const remainI  = Number(st.time_remaining_int ?? 0);
let toShowInt = (running || finished) ? remainI : Math.round(budget);
if (!Number.isFinite(toShowInt)) {
  const remainF = Number(st.time_remaining_s);
  toShowInt = Number.isFinite(remainF) ? Math.floor(remainF) : Math.floor(Number(st.t) || 0);
}

timerEl.textContent = formatTimeSec(toShowInt);

// âœ… ìƒ‰ìƒ ì¡°ê±´ ì¶”ê°€
if (Math.abs(toShowInt) <= 2) {
  timerEl.style.color = "#9effb5";   // ì´ˆë¡ìƒ‰
  timerEl.classList.remove('bad');
} else if (toShowInt < 0) {
  timerEl.style.color = "";          // ê¸°ë³¸ ìƒ‰ìƒ (CSS .stat)
  timerEl.classList.add('bad');      // ìŒìˆ˜ë©´ ë¹¨ê°•
} else {
  timerEl.style.color = "";          // ê¸°ë³¸ ìƒ‰ìƒ (CSS .stat)
  timerEl.classList.remove('bad');
} 

  // ê·¸ë˜í”„/ë¯¸ë‹ˆ ì¸ë””ì¼€ì´í„°
  drawHUD(st);
  drawBrakeLadderMini(st);

  // âš  í”¼ë“œë°±(fb) UIëŠ” ì—¬ê¸°ì„œ ê±´ë“œë¦¬ì§€ ë§ˆì„¸ìš” (ì–¸ì–´ í† ê¸€ì€ setLangì—ì„œ ì²˜ë¦¬)

// âœ… ì¬ì‹œì‘ FAB í‘œì‹œ/ìˆ¨ê¹€
if (st.finished) {
  if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
    btnMobileRestart.classList.remove('hide');  // ëª¨ë°”ì¼ì´ë©´ í‘œì‹œ
  } else {
    btnMobileRestart.classList.add('hide');     // PCì—ì„œëŠ” ìˆ¨ê¹€ ìœ ì§€
  }
} else {
  btnMobileRestart.classList.add('hide');       // ê²Œì„ ì§„í–‰ ì¤‘ì—ëŠ” í•­ìƒ ìˆ¨ê¹€
}
};

/* ===== HUD ê·¸ë¦¬ê¸° (ê¸°ì¡´ ìœ ì§€) ===== */
function drawHUD(st){
  const dpr=devicePixelRatio||1, w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  const v0=st.v, lever=st.lever_notch, currentPos=st.pos??0, stopPos=st.stopPos??500;
  const remaining=(typeof st.remaining_m==="number")?Math.max(0,st.remaining_m):Math.max(0,stopPos-currentPos);
  const maxDecel=Math.max(...Object.values(brakeDecels)); const maxStop=maxDecel>0?(v0*v0)/(2*maxDecel):0;
  const speedFactor=Math.max(.3,Math.min(1,v0/10)); const adjusted=remaining*(1+(1-speedFactor)*.5);
  const s_b1=(brakeDecels[1]??0)>0?(v0*v0)/(2*brakeDecels[1]):0, s_b2=(brakeDecels[2]??0)>0?(v0*v0)/(2*brakeDecels[2]):0;
  const target=Math.max(1,maxStop*1.5,Math.max(1,Math.sqrt(adjusted)*10)*1.2,s_b1*1.1,s_b2*1.1);
  prevMaxDistance = prevMaxDistance===0 ? target : prevMaxDistance*.9 + target*.1;

  const left=48*dpr, right=12*dpr, usableW=w-left-right, X=d=>left+usableW*(d/prevMaxDistance);
  const vmax=Math.max(1,v0*3.6*1.2);
  const bottom=28*dpr, top=12*dpr, usableH=h-bottom-top, Y=v=>h-bottom-usableH*(v/vmax);

  ctx.strokeStyle="#20334d"; ctx.lineWidth=1*dpr; ctx.beginPath(); ctx.moveTo(left,top); ctx.lineTo(left,h-bottom); ctx.lineTo(w-right,h-bottom); ctx.stroke();

  ctx.fillStyle="#888"; ctx.font=`${10*dpr}px sans-serif`; ctx.textAlign="center"; ctx.textBaseline="top";
  for(let d=0; d<=prevMaxDistance; d+=100){ const x=X(d); ctx.beginPath(); ctx.moveTo(x,h-bottom); ctx.lineTo(x,h-bottom+4*dpr); ctx.stroke(); ctx.fillText(`${Math.round(d)}`,x,h-bottom+6*dpr); }
  ctx.textAlign="right"; ctx.textBaseline="middle";
  for(let k=0;k<=vmax;k+=10){ const y=Y(k); ctx.beginPath(); ctx.moveTo(left-4*dpr,y); ctx.lineTo(left,y); ctx.stroke(); ctx.fillText(`${k}`,left-6*dpr,y); }

  ctx.lineWidth=2*dpr; 
  const maxNotch = vehicle?.notches ?? 10;   // ì´ ê°œìˆ˜(0~maxIdx)
  const maxIdx   = maxNotch - 1;  // EB ì¸ë±ìŠ¤
  for(let n=0;n<maxNotch;n++){
    const a=brakeDecels[n]??0; if(a<=0) continue;
    const s=(v0*v0)/(2*a);
    ctx.beginPath(); ctx.strokeStyle = n===lever ? "#ffae00" : "#3fa9ff";
    for(let i=0;i<=100;i++){
      const f=i/100, ds=s*f, v=Math.sqrt(Math.max(0,v0*v0-2*a*ds));
      const x=X(ds), y=Y(v*3.6); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.fillStyle=n===lever?"#ffae00":"#3fa9ff"; ctx.font=`${12*dpr}px 'Orbitron', sans-serif`;
    const tX=X(s); const label = (n===0) ? "N" : (n===maxIdx ? "EB" : `B${n}`);
    ctx.fillText(label, tX+5*dpr, Y(0)+12*dpr);
  }

  const xRed=X(remaining); ctx.strokeStyle="#f00"; ctx.lineWidth=1.5*dpr; ctx.beginPath(); ctx.moveTo(xRed,Y(0)); ctx.lineTo(xRed,Y(vmax)); ctx.stroke();
  ctx.fillStyle="#f00"; ctx.font=`${14*dpr}px 'Orbitron', sans-serif`; ctx.textAlign="center"; ctx.fillText("ë‚¨ì€ ê±°ë¦¬", xRed, Y(vmax)-18*dpr);

  // const ribbonW=16*dpr, ribbonH=h*.9, ribbonX=w-right-ribbonW-10*dpr+20, ribbonY=((h-ribbonH)/2)-32;
  // ctx.fillStyle="rgba(100,100,100,.1)"; ctx.strokeStyle="rgba(100,100,100,.3)"; ctx.lineWidth=1.5*dpr;
  // ctx.beginPath(); ctx.rect(ribbonX,ribbonY,ribbonW,ribbonH); ctx.fill(); ctx.stroke();

  // const centerY=(ribbonY+ribbonH/2)-14, barH=12*dpr;
  // ctx.fillStyle="rgba(60,60,60,.9)"; ctx.fillRect(ribbonX+2*dpr, centerY-barH/2, ribbonW-4*dpr, barH);

  // PC/ëª¨ë°”ì¼ íŒë³„
  const isMobile = window.innerWidth < 768; 

  // ë³´ì •ê°’ ì„¤ì • (ì›í•˜ëŠ” ê°’ìœ¼ë¡œ ìˆ˜ì • ê°€ëŠ¥)
  // -32 -14
  const offsetRibbonY = isMobile ? -32 : -12; 
  const offsetCenterY = isMobile ? -14 : -5; 

  // ë¦¬ë³¸ ìœ„ì¹˜/í¬ê¸° ê³„ì‚°
  const ribbonW = 16 * dpr, 
        ribbonH = h * .9, 
        ribbonX = w - right - ribbonW - 10 * dpr + 20, 
        ribbonY = ((h - ribbonH) / 2) + offsetRibbonY;

  ctx.fillStyle = "rgba(100,100,100,.1)";
  ctx.strokeStyle = "rgba(100,100,100,.3)";
  ctx.lineWidth = 1.5 * dpr;
  ctx.beginPath();
  ctx.rect(ribbonX, ribbonY, ribbonW, ribbonH);
  ctx.fill();
  ctx.stroke();

  // ì¤‘ì•™ ë°”
  const centerY = (ribbonY + ribbonH / 2) + offsetCenterY, 
        barH = 12 * dpr;

  ctx.fillStyle = "rgba(60,60,60,.9)";
  ctx.fillRect(ribbonX + 2 * dpr, centerY - barH / 2, ribbonW - 4 * dpr, barH);

  const rem=Math.min(Math.max(st.remaining_m??st.L,-st.L), st.L);
  const diamondW=16*dpr, diamondH=10*dpr, dX=ribbonX+ribbonW/2;
  const normalized=(rem-(-7))/(7-(-7));
  const dY=ribbonY+(ribbonH*(1-normalized))-diamondH/2;
  const adjY=Math.min(Math.max(dY, ribbonY-10*dpr), ribbonY+ribbonH-diamondH+10*dpr);
  ctx.fillStyle="#444"; ctx.strokeStyle="#222"; ctx.lineWidth=2*dpr; ctx.beginPath();
  ctx.moveTo(dX, adjY-diamondH/2); ctx.lineTo(dX+diamondW/2, adjY); ctx.lineTo(dX, adjY+diamondH/2); ctx.lineTo(dX-diamondW/2, adjY);
  ctx.closePath(); ctx.fill(); ctx.stroke();

/* === TASC ê²½ê³ ë“± (HUD ìœ„) === */
/* === TASC ê²½ê³ ë“± (HUD ìœ„) === */
/* === TASC ê²½ê³ ë“± (HUD ìœ„) === */
{
  const pad = 8 * dpr;       // í…ìŠ¤íŠ¸ì™€ í…Œë‘ë¦¬ ì‚¬ì´ ì—¬ë°±
  const textW = 18 * dpr;    
  const textH = 9 * dpr;     
  const radius = 2 * dpr;    // ëª¨ì„œë¦¬ ë°˜ê²½

  const lightW = textW + pad*2 + 8*dpr; // ê¸°ì¡´ë³´ë‹¤ 6px ë” ëŠ˜ë¦¼
  const lightH = textH + pad*2 - 2*dpr; // ê¸°ì¡´ë³´ë‹¤ 2px ì¤„ì„

  const isMobile = window.innerWidth < 768;
  const lightX = isMobile 
    ? w - lightW - 35 * dpr
    : w - lightW - 30 * dpr;
  const lightY = 15 * dpr;

  const blinkOn = Math.floor(Date.now() / 250) % 2 === 0;

  // Set the fill color based on the state
  let fillColor = "#444"; 
  if (!st.tasc_armed && !st.tasc_enabled) fillColor = "#444";
  else if (st.tasc_active) fillColor = "#fec670";
  else if (st.tasc_armed && !st.tasc_active && blinkOn) fillColor = "#fec670";

  // Draw rounded rectangle for TASC light
  ctx.beginPath();
  ctx.moveTo(lightX + radius, lightY);
  ctx.lineTo(lightX + lightW - radius, lightY);
  ctx.quadraticCurveTo(lightX + lightW, lightY, lightX + lightW, lightY + radius);
  ctx.lineTo(lightX + lightW, lightY + lightH - radius);
  ctx.quadraticCurveTo(lightX + lightW, lightY + lightH, lightX + lightW - radius, lightY + lightH);
  ctx.lineTo(lightX + radius, lightY + lightH);
  ctx.quadraticCurveTo(lightX, lightY + lightH, lightX, lightY + lightH - radius);
  ctx.lineTo(lightX, lightY + radius);
  ctx.quadraticCurveTo(lightX, lightY, lightX + radius, lightY);
  ctx.closePath();

  // Fill the rectangle with the color
  ctx.fillStyle = fillColor;
  ctx.fill();

  // Apply gradient stroke for a 3D effect
  const gradient = ctx.createLinearGradient(lightX, lightY, lightX, lightY + lightH);
  gradient.addColorStop(0, "#999");  // Lighter gray at the top
  gradient.addColorStop(1, "#444");  // Darker gray at the bottom

  // Set stroke style to the gradient
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = gradient;
  ctx.stroke();

  // Set text style and alignment for TASC text
  let tascTextColor = "#fff"; // ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ (í°ìƒ‰)

  // ë¶ˆì´ ë“¤ì–´ì™”ì„ ë•Œ ìë™ ë²„íŠ¼ì²˜ëŸ¼ ê²€ì€ìƒ‰ìœ¼ë¡œ ë°”ê¾¸ê¸°
  if (st.tasc_enabled && st.tasc_active) {
    tascTextColor = "#000";  // ë¶ˆì´ ë“¤ì–´ì˜¤ë©´ í…ìŠ¤íŠ¸ ìƒ‰ìƒ ê²€ì€ìƒ‰
  }

  ctx.fillStyle = tascTextColor; // í…ìŠ¤íŠ¸ ìƒ‰ìƒ ë³€ê²½
  ctx.font = `${7 * dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";

  // Split text by newline and position each line
  const text = "TASC\nìë™";
  const lines = text.split("\n");
  const lineHeight = 10 * dpr; // Adjust this value for spacing between lines

  // Draw each line at the center position
  lines.forEach((line, index) => {
    ctx.fillText(line, lightX + lightW / 2, lightY + lightH / 2 + index * lineHeight);
  });

  /* === ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ (ì´ˆë¡ìƒ‰) === */
  const stopBtnX = lightX - lightW - 3 * dpr;  // ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ì˜ X ìœ„ì¹˜
  const stopBtnY = lightY;  // Y ìœ„ì¹˜ëŠ” TASC ê²½ê³ ë“±ê³¼ ë™ì¼í•˜ê²Œ

  const stopBtnW = textW + pad * 2 + 8 * dpr; // ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ì˜ ë„ˆë¹„
  const stopBtnH = textH + pad * 2 - 2 * dpr; // ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ì˜ ë†’ì´

  let stopBtnColor = "#444"; // ê¸°ë³¸ íšŒìƒ‰
  let stopTextColor = "#fff"; // ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ (í°ìƒ‰)

  // Check if the button should be green (ì •ìœ„ì¹˜ ì •ì°¨ ì™„ë£Œ ìƒíƒœ)
  if (st.tasc_enabled && st.v == 0) {
    stopBtnColor = "#9be071";  // ì´ˆë¡ìƒ‰ (ì •ìœ„ì¹˜ ì •ì°¨ ì™„ë£Œ ìƒíƒœ)
    stopTextColor = "#000";  // ì´ˆë¡ìƒ‰ì¼ ë•Œ í…ìŠ¤íŠ¸ ìƒ‰ìƒ ê²€ì€ìƒ‰
  }

  // Draw rounded rectangle for Stop Button
  ctx.beginPath();
  ctx.moveTo(stopBtnX + radius, stopBtnY);
  ctx.lineTo(stopBtnX + stopBtnW - radius, stopBtnY);
  ctx.quadraticCurveTo(stopBtnX + stopBtnW, stopBtnY, stopBtnX + stopBtnW, stopBtnY + radius);
  ctx.lineTo(stopBtnX + stopBtnW, stopBtnY + stopBtnH - radius);
  ctx.quadraticCurveTo(stopBtnX + stopBtnW, stopBtnY + stopBtnH, stopBtnX + stopBtnW - radius, stopBtnY + stopBtnH);
  ctx.lineTo(stopBtnX + radius, stopBtnY + stopBtnH);
  ctx.quadraticCurveTo(stopBtnX, stopBtnY + stopBtnH, stopBtnX, stopBtnY + stopBtnH - radius);
  ctx.lineTo(stopBtnX, stopBtnY + radius);
  ctx.quadraticCurveTo(stopBtnX, stopBtnY, stopBtnX + radius, stopBtnY);
  ctx.closePath();

  // Fill the button with the color
  ctx.fillStyle = stopBtnColor;
  ctx.fill();

  // Apply gradient stroke for a 3D effect
  const stopBtnGradient = ctx.createLinearGradient(stopBtnX, stopBtnY, stopBtnX, stopBtnY + stopBtnH);
  stopBtnGradient.addColorStop(0, "#999");  // Lighter gray at the top
  stopBtnGradient.addColorStop(1, "#444");  // Darker gray at the bottom

  // Set stroke style to the gradient
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = stopBtnGradient;
  ctx.stroke();

  // Set text style and alignment for Stop Button text
  ctx.fillStyle = stopTextColor;  // í…ìŠ¤íŠ¸ ìƒ‰ìƒì€ ì •ìœ„ì¹˜ ìƒíƒœì— ë”°ë¼ ê²°ì •
  ctx.font = `${7 * dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";

  // Draw text for the Stop Button
  const stopText = "TASC\nì •ìœ„ì¹˜";
  const stopLines = stopText.split("\n");
  const stopLineHeight = 10 * dpr;  // Adjust this value for spacing between lines

  // Draw each line of text at the center position
  stopLines.forEach((line, index) => {
    ctx.fillText(line, stopBtnX + stopBtnW / 2, stopBtnY + stopBtnH / 2 + index * stopLineHeight);
  });
}


}


/* ===== ë¸Œë ˆì´í¬ ë¯¸ë‹ˆ ì¸ë””ì¼€ì´í„° ===== */
const ladderCanvas = document.getElementById('brakeLadder');
function sizeLadderCanvas() {
  if (!ladderCanvas) return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = ladderCanvas.clientWidth;
  const cssH = ladderCanvas.clientHeight;
  ladderCanvas.width  = Math.max(1, Math.round(cssW * dpr));
  ladderCanvas.height = Math.max(1, Math.round(cssH * dpr));
}
addEventListener('resize', sizeLadderCanvas);
sizeLadderCanvas();

function drawBrakeLadderMini(st) {
  const ctx2 = ladderCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const w = ladderCanvas.width, h = ladderCanvas.height;
  if (!w || !h) return;
  ctx2.clearRect(0, 0, w, h);

  const accArr  = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const notches = accArr ? accArr.length : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);
  const ebIdx   = accArr ? Math.max(1, accArr.length - 1) : Math.max(1, notches - 1);
  const blocks  = ebIdx;
  const cur     = Math.max(0, Math.min(ebIdx, st.lever_notch|0));

  ctx2.fillStyle = "rgba(100,100,100,0.10)";
  ctx2.fillRect(0, 0, w, h);

  const pad  = 2 * dpr;
  const gap  = Math.max(2 * dpr, Math.round(h * 0.02));
  const bH   = (h - pad*2 - gap*(blocks-1)) / blocks;
  const bW   = w - pad*2;
  const x    = pad;

  for (let k = 1; k <= ebIdx - 1; k++) {
    const i = k - 1;
    const y = h - pad - (i + 1) * bH - i * gap;
    ctx2.fillStyle = "rgba(60,80,100,0.35)";
    ctx2.fillRect(x, y, bW, bH);
    if (cur !== ebIdx && k <= cur) { ctx2.fillStyle = "#ffd34d"; ctx2.fillRect(x, y, bW, bH); }
    ctx2.strokeStyle = "rgba(20,30,45,0.6)";
    ctx2.lineWidth   = 1 * dpr;
    ctx2.strokeRect(x, y, bW, bH);
  }

  const yEB = h - pad - (ebIdx) * bH - (ebIdx - 1) * gap;
  ctx2.fillStyle = "rgba(60,80,100,0.35)";
  ctx2.fillRect(x, yEB, bW, bH);
  if (cur === ebIdx) { ctx2.fillStyle = "#ff5757"; ctx2.fillRect(x, yEB, bW, bH); }
  ctx2.strokeStyle = "rgba(20,30,45,0.6)";
  ctx2.lineWidth   = 1 * dpr;
  ctx2.strokeRect(x, yEB, bW, bH);

  
}

/* ===== ì „ë™ì°¨/ì‹œë¦¬ì¦ˆ/í¸ì„± ===== */
const TRAIN_DB={
  E233:[
    {code:"JR EAST E233-1000", lines:"ê²Œì´íŒí† í˜¸ì¿ Â·ë„¤ê¸°ì‹œ", file:"./e233_1000.json", lengths:[10]},
    {code:"JR EAST E233-2000", lines:"ì¡°ë°˜ ê°ì—­Â·ì¾Œì†", file:"./e233_2000.json", lengths:[10]},
    {code:"JR EAST E233-3000", lines:"ë„ì¹´ì´ë„Â·ë„í˜¸ì¿ Â·íƒ€ì¹´ì‚¬í‚¤Â·ìš°ì—ë…¸ë„ì¿„/ì†Œë¶€ì¾Œì†Â·ì¡°ë°˜ ì§í†µ", file:"./e233_3000.json", lengths:[5,10,15]}
  ],
  E235:[
    {code:"JR EAST E235-0", lines:"ì•¼ë§ˆë…¸í…Œ", file:"./e235_0.json", lengths:[11]},
    {code:"JR EAST E235-1000", lines:"ìš”ì½”ìŠ¤ì¹´Â·ì†Œë¶€ì¾Œì†", file:"./e235_1000.json", lengths:[4,11,15]}
  ],
  JRW223: [
    { code: "JR WEST 223-0",
      lines: "ì˜¤ì‚¬ì¹´ ìˆœí™˜ì„  Â· í•œì™€ì„  Â· ê°„ì‚¬ì´ê³µí•­ì„  ì§ê²° Â· ê¸°ë…¸ì¿ ë‹ˆì„ ",
      file: "./223_0000.json", lengths: [4] },
    { code: "JR WEST 223-1000",
      lines: "ë¹„ì™€ì½”Â·JR êµí† Â·JR ê³ ë²  ë¼ì¸ ë“±",
      file: "./223_1000.json", lengths: [4,8] }
  ],
  JRW225: [
    { code: "JR WEST 225-0",
      lines: "ë¹„ì™€ì½”Â·JR êµí† Â·JR ê³ ë²  ë¼ì¸ ë“±",
      file: "./225_0000.json", lengths: [4,8] },
    { code: "JR WEST 225-5000",
      lines: "ì˜¤ì‚¬ì¹´ ìˆœí™˜ì„  Â· í•œì™€ì„  Â· ê°„ì‚¬ì´ê³µí•­ì„ ",
      file: "./225_5000.json", lengths: [4] },
    { code: "JR WEST 225-6000",
      lines: "JR ê³ ë² ì„  Â· í›„ì¿ ì¹˜ì•¼ë§ˆì„ ",
      file: "./225_6000.json", lengths: [4,6] }
  ],
  JRW323: [{ code: "JR WEST 323-0", lines: "ì˜¤ì‚¬ì¹´ ìˆœí™˜ì„  ì „ìš©", file: "./323_0000.json", lengths: [8] }],
  JRW285: [{ code: "JR WEST 285-0/3000", lines: "ì¼ë°˜ ì¹¨ëŒ€íŠ¹ê¸‰ ì„ ë¼ì´ì¦ˆ ì´ì¦ˆëª¨Â·ì„¸í† ", file: "./285.json", lengths: [7, 14] }],
  JRH261: [{ code: "JR HOKKAIDO KiHa 261-5000", lines: "ë¶í•´ë„ì˜ í˜¹í•œì— ìµœì í™”ëœ íŠ¹ê¸‰ ë””ì ¤ë™ì°¨", file: "./261_5000.json", lengths: [4, 5, 6, 10] }],
JR103: [{
  code: "JR/JNR 103-0",
  lines: "1960~80ë…„ëŒ€ ì¼ë³¸ í†µê·¼í˜• ì „ë™ì°¨ì˜ ìƒì§•",
  file: "./103.json",
  lengths: [4, 6, 8, 10, 15]
}],
EF510: [{
  code: "JR EAST Cassiopeia â€¢ ì´ˆí˜¸í™” ì¹¨ëŒ€íŠ¹ê¸‰",
  lines: "ìš°ì—ë…¸â†”ì•„ì˜¤ëª¨ë¦¬",
  file: "./e26.json",
  lengths: [13]
}],
K3000: [{
  code: "Keisei 3000",
  lines: "ì¼€ì´ì„¸ì´ ë³¸ì„ , ë‚˜ë¦¬íƒ€ ê³µí•­ì„ ",
  file: "./keisei3000.json",
  lengths: [6, 8]
}],
T5300: [{
  code: "Toei 5300",
  lines: "ë„ì—ì´ ì•„ì‚¬ì¿ ì‚¬ì„ , ì¼€ì´ì„¸ì´ ë³¸ì„ , ê²Œì´í ë³¸ì„ ",
  file: "./toei5300.json",
  lengths: [8]
}]


};

const trainFamilyEl=document.getElementById('trainFamily');
const trainSeriesEl=document.getElementById('trainSeries');
const trainLengthEl=document.getElementById('trainLength');

function setTrainLengthOptions(lengths){
  trainLengthEl.innerHTML="";
  lengths.forEach(len=>{
    const opt=document.createElement('option');
    opt.value=String(len); opt.textContent=`${len}ëŸ‰`;
    trainLengthEl.appendChild(opt);
  });
  updateTrainLength();
}
function loadVehicleFile(filePath){
  fetch(filePath + cacheBust(), { cache: 'no-store' })
    .then(res => res.json())
    .then(data => {
      vehicle = data;
      vehicle.notches = (vehicle.notch_accels || []).length;
      document.getElementById('carName').textContent = vehicle.name;

      brakeDecels = {};
      if (vehicle.notch_accels && vehicle.notches) {
        for (let i = 0; i < vehicle.notches; i++) {
          brakeDecels[i] = Math.abs(vehicle.notch_accels[vehicle.notches - 1 - i] ?? 0);
        }
      }

      if (ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ type: "cmd", payload: { name: "setVehicleFile", file: filePath } }));
      }
      sendLoadRate();
    })
    .catch(console.error);
}
function populateSeries(){
  const fam=trainFamilyEl.value, list=TRAIN_DB[fam]||[];
  trainSeriesEl.innerHTML="";
  list.forEach((s,i)=>{
    const opt=document.createElement('option');
    opt.value=s.file; opt.dataset.lengths=JSON.stringify(s.lengths);
    opt.textContent=`${s.code} (${s.lines})`;
    if(i===0) opt.selected=true;
    trainSeriesEl.appendChild(opt);
  });
  if(list[0]){ setTrainLengthOptions(list[0].lengths); loadVehicleFile(list[0].file); }
}
trainFamilyEl.addEventListener('change', populateSeries);
trainSeriesEl.addEventListener('change',(e)=>{
  const opt=e.target.selectedOptions[0];
  const lengths=JSON.parse(opt.dataset.lengths||"[]");
  setTrainLengthOptions(lengths);
  loadVehicleFile(opt.value);
});
populateSeries(); // ìµœì´ˆ ì„¸íŒ…
</script>

<!-- ===== 10s ì–¸ì–´ í† ê¸€ (ko <-> en), í”¼ë“œë°± í¬í•¨ ===== -->
<script>


// ===== ì–¸ì–´ í† ê¸€ =====
(function(){
  const dict = {
    ko: {
      htmlLang: "ko",
      docTitle: "TASC Simulator",
      labelRemainTime: "ë‚¨ì€ì‹œê°„",
      labelSpeed: "ì†ë„",
      labelRemainDist: "ì •ì°¨",
      labelGrade: "êµ¬ë°°",
      labelNotch: "ì œë™",
      labelStartKey: "ì‹œì‘",
      labelUp: "ê°•í™”",
      labelDown: "ì™„í™”",
      labelRelease: "í•´ë°©",
      subtitleIntro: 
  "B1/B2ë‹¨ìœ¼ë¡œ ì œë™ì„ ì‹œì‘í•´ ë‚¨ì€ê±°ë¦¬ <b>150m</b> (P3 TASC ì§€ìƒì) ì§€ì ê¹Œì§€ ì†ë„ë¥¼ <b>60km/h</b> ì´í•˜ë¡œ ë‚®ì¶”ì„¸ìš”. ê·¸ ì´í›„ì—ëŠ” <b>TASC(ìë™ì •ì°¨)</b>ê°€ ìë™ìœ¼ë¡œ ì œë™ì„ ì´ì–´ë°›ìŠµë‹ˆë‹¤.",

      labelTASC: "TASC",
      labelTrain: "ì „ë™ì°¨",
      labelSeries: "ì‹œë¦¬ì¦ˆ",
      labelInitSpeed: "ì´ˆê¸° ì†ë„ (km/h)",
      labelInitDist: "ê±°ë¦¬ (m)",
      labelGradeInput: "ê²½ì‚¬ë„ (â€°)",
      labelWeather: "ë‚ ì”¨",
      labelLoadRate: "ìŠ¹ê° íƒ‘ìŠ¹ë¥  (%)",
      labelTrainLength: "í¸ì„±",
      btnStart: "Start (Space)",
      btnMobileRestart: "ì¬ì‹œì‘",
      feedback: {
        early_good: "ì´ˆê¸° ì œë™ì„ ìˆ˜í–‰í•¨ â€” ìŠ¹ì°¨ê° ì–‘í˜¸",
        early_bad: "ì´ˆê¸° ì œë™ì„ ê²Œì„ë¦¬í•¨ â€” ìŠ¹ì°¨ê° ë¶ˆì¾Œ",
        stop_good: "ì •ì°¨ ì‹œ B1ë¡œ ì •ì°¨í•¨ â€” ìŠ¹ì°¨ê° ì–‘í˜¸",
        stop_bad: "ì •ì°¨ ì‹œ B1ë¡œ ì •ì°¨í•˜ì§€ ì•ŠìŒ â€” ìŠ¹ì°¨ê° ë¶ˆì¾Œ",
        step_good: "ê¸°ë³¸ì œë™ (ê³„ë‹¨ì œë™/ì™„í•´) ìˆ˜í–‰í•¨",
        step_bad: "ê¸°ë³¸ì œë™ (ê³„ë‹¨ì œë™/ì™„í•´) ë¯¸í¡ â€” ìŠ¹ê° ì ë¦¼",
        eb_good: "ì˜ì—… ì•ˆì „ ì œë™ë²”ìœ„ ì¤€ìˆ˜",
        eb_bad: "ë¶ˆí•„ìš”í•œ ë¹„ìƒì œë™(EB) ì‚¬ìš© â€” ê¸‰ê°ì† ì¶©ê²©",
        score: n=>`ìµœì¢… ì ìˆ˜: ${n}ì `,
        stopErr: m=>`ì •ì§€ ì˜¤ì°¨: ${m.toFixed(2)} m`,
         hintIdle: () => {
          const tips = [
            "íŒ: B1/B2ë¡œ ì†ë„ë¥¼ 60 km/h ì´í•˜ë¡œ ë‚®ì¶˜ ë’¤ í•´ë°©(Në‹¨)í•˜ì§€ ë§ê³  ë§ˆìŠ¤ì½˜ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ì„¸ìš”.",
            "íŒ: TASC ì •ì°¨ í‘œì‹œë“±ì´ ì¼œì§€ë©´ TASCê°€ ìë™ ì œë™ì„ ì‹œì‘í–ˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.",
            "íŒ: TASC ì •ì°¨ í‘œì‹œë“±ì´ ê¹œë¹¡ì´ë©´, TASC ê°œì… ì „ì— ìˆ˜ë™ ì¡°ì‘ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.",
            "íŒ: ì—´ì°¨ê°€ ì •ìœ„ì¹˜ì— ë„ë‹¬í•˜ë©´ TASC ì •ìœ„ì¹˜ í‘œì‹œë“±ì´ ì¼œì§‘ë‹ˆë‹¤.",
            "íŒ: ë‚¨ì€ ê±°ë¦¬ë¥¼ í™•ì¸í•˜ë©° ì—¬ìœ  ìˆê²Œ B1ìœ¼ë¡œ ì •ì°¨í•˜ì—¬ ìŠ¹ì°¨ê°ì„ í™•ë³´í•˜ì„¸ìš”.",
            "íŒ: Aí‚¤ëŠ” ìµœëŒ€ ìƒìš© ì œë™, Dí‚¤ëŠ” B1 ì œë™, Eí‚¤ëŠ” ë¹„ìƒì œë™ì„ ë°œë™ì‹œí‚µë‹ˆë‹¤.",
            "íŒ: ì •ì°¨ ì§ì „ ë§ˆìŠ¤ì½˜ì„ í’€ì—ˆë‹¤ ë‹¤ì‹œ ì¡°ì‘í•˜ëŠ” ì¼ëª… \"í†±ì§ˆ\" í–‰ìœ„ëŠ” ìŠ¹ì°¨ê°ì„ í¬ê²Œ ì €í•˜ì‹œí‚µë‹ˆë‹¤.",
          ];

          return tips[Math.floor(Math.random() * tips.length)];
        },
        hintAgain: "Spaceë¡œ ë‹¤ì‹œ ì‹œì‘ Â· N í•´ë°© Â· W/Së¡œ ì¡°ì‘"
      }
    },
    en: {
      htmlLang: "en",
      docTitle: "TASC Simulator",
      labelRemainTime: "STA",
      labelSpeed: "Speed",
      labelRemainDist: "Distance",
      labelGrade: "Grade",
      labelNotch: "Brake",
      labelStartKey: "Start",
      labelUp: "B+",
      labelDown: "B-",
      labelRelease: "Release",
      subtitleIntro: 
  "Begin braking with B1/B2 and reduce speed to below <b>60km/h</b> by <b>150m</b> remaining (P3 TASC beacon). After that, <b>TASC (Autopilot)</b> takes over brake control.",


      labelTASC: "TASC",
      labelTrain: "Train",
      labelSeries: "Series",
      labelInitSpeed: "Initial Speed (km/h)",
      labelInitDist: "Distance (m)",
      labelGradeInput: "Grade (â€°)",
      labelWeather: "Weather",
      labelLoadRate: "Passenger Load (%)",
      labelTrainLength: "Formation",
      btnStart: "Start (Space)",
      btnMobileRestart: "Restart",
      feedback: {
  early_good: "You braked early â€” the ride was smooth.",
  early_bad: "You braked late â€” the ride felt rough.",
  stop_good: "Stopped at B1 â€” the ride was smooth.",
  stop_bad: "Failed to stop at B1 â€” the ride felt rough.",
  step_good: "Stepwise braking was applied correctly",
  step_bad: "Stepwise braking was poor, causing jolts and discomfort for passengers",
  eb_good: "Safe braking range observed â€” no EB applied",
  eb_bad: "Unnecessary EB applied, causing a harsh jolt",
  score: n => `Final score: ${n}`,
  stopErr: m => `Stopping error: ${m.toFixed(2)} m`,
  hintIdle: () => {
    const tips = [
      "Tip: Reduce speed below 60 km/h with B1/B2 and keep the master controller in place (do not release with N).",
      "Tip: If the TASC stop indicator lights up, it means TASC has started automatic braking.",
      "Tip: If the TASC stop indicator flashes, you can manually intervene before TASC takes over.",
      "Tip: When the train reaches the exact stop position, the TASC stop-position indicator will light up.",
      "Tip: Press A for maximum service brake, D for B1 brake, and E for emergency brake.",
      "Tip: Check the remaining distance and stop gently with B1 to ensure a smooth ride.",
      "Tip: Reapplying and releasing the master controller just before stopping can severely affect ride comfort."

    ];

    return tips[Math.floor(Math.random() * tips.length)];
  },

  hintAgain: "Press Space to restart, N to release, W/S to brake."
}
    }
  };

  const nodes = {
    labelRemainTime: document.getElementById("labelRemainTime"),
    labelSpeed: document.getElementById("labelSpeed"),
    labelRemainDist: document.getElementById("labelRemainDist"),
    labelGrade: document.getElementById("labelGrade"),
    labelNotch: document.getElementById("labelNotch"),
    subtitleIntro: document.getElementById("subtitleIntro"),
    labelTASC: document.getElementById("labelTASC"),
    labelTrain: document.getElementById("labelTrain"),
    labelSeries: document.getElementById("labelSeries"),
    labelInitSpeed: document.getElementById("labelInitSpeed"),
    labelInitDist: document.getElementById("labelInitDist"),
    labelGradeInput: document.getElementById("labelGradeInput"),
    labelWeather: document.getElementById("labelWeather"),
    labelLoadRate: document.getElementById("labelLoadRate"),
    labelTrainLength: document.getElementById("labelTrainLength"),
    btnStart: document.getElementById("btnStart"),
    btnMobileRestart: document.getElementById("btnMobileRestart"),
    fb: document.getElementById("fb")
  };

  function setLang(lang){
    const d = dict[lang];
    document.documentElement.lang = d.htmlLang;
    document.title = d.docTitle;

    [
      "labelRemainTime","labelSpeed","labelRemainDist","labelGrade","labelNotch",
      "labelStartKey","labelUp","labelDown","labelRelease",
      "labelTASC","labelTrain","labelSeries","labelInitSpeed","labelInitDist",
      "labelGradeInput","labelWeather","labelLoadRate","labelTrainLength"
    ].forEach(k => { if(nodes[k]) nodes[k].innerText = d[k]; });

    if(nodes.subtitleIntro) nodes.subtitleIntro.innerHTML = d.subtitleIntro;
    if(nodes.btnStart) nodes.btnStart.textContent = d.btnStart;
    if(nodes.btnMobileRestart) nodes.btnMobileRestart.textContent = d.btnMobileRestart;

    // ---- í”¼ë“œë°± ë²ˆì—­ ----
    if (nodes.fb) {
      const fbd = d.feedback;
      const st = window.st;
      if (st && st.finished) {
        const issues = st.issues ?? {};
        let rows = [];
        rows.push({ bad: !!issues.early_brake_too_short, goodText: fbd.early_good, badText: fbd.early_bad });
        rows.push({ bad: !!issues.stop_not_b1,           goodText: fbd.stop_good,  badText: fbd.stop_bad  });
        rows.push({ bad: !!issues.step_brake_incomplete, goodText: fbd.step_good,  badText: fbd.step_bad  });
        rows.push({ bad: !!issues.unnecessary_eb_usage,  goodText: fbd.eb_good,    badText: fbd.eb_bad    });

        let html = rows.map(r =>
          `<div class="${r.bad ? "bad" : "ok"}">${r.bad ? r.badText : r.goodText}</div>`
        ).join("");

        const stopErr = Number(st.stop_error_m ?? 0);
        const score   = Number(st.score ?? 0);
        const goodErr = Math.abs(stopErr) <= 2;

        html += `<div class="${goodErr ? "ok" : "warn"}">${fbd.stopErr(stopErr)}</div>`;
        html += `<div class="${goodErr ? "ok" : "warn"}">${fbd.score(score)}</div>`;
        html += `<div style="margin-top:8px;font-size:12px;color:#a6b7d1">${fbd.hintAgain}</div>`;
        nodes.fb.innerHTML = html;
      } else {
        nodes.fb.textContent = fbd.hintIdle();
      }
    }
  }

  // ===== 5ì´ˆë§ˆë‹¤ í† ê¸€ =====
  let current = "ko";
  setLang(current);
  setInterval(()=>{
    current = (current==="ko") ? "en" : "ko";
    setLang(current);
  }, 7000);
})();

</script>

<footer style="text-align:center; font-size:12px; color:#888; padding:8px 0; user-select:none;">
  Â©2025 Hyungsuk Choi, University of Maryland
</footer>
</body>
</html>