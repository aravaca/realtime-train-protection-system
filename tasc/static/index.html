<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>TASC Simulator</title>
<style>
html, body {
  margin: 0;
  background: radial-gradient(circle at 50% 20%, #0b0f14, #05070a);
  background-attachment: fixed;
  color: #e7f0ff;
  font-family: 'Orbitron', system-ui, Segoe UI, Roboto, Apple SD Gothic Neo, AppleGothic, sans-serif;
}
#wrap { max-width: 960px; margin: 18px auto; padding: 0 12px; }
.row { display: flex; gap: 12px; align-items: center; }
.card {
  background: rgba(18, 24, 38, 0.7);
  border: 1px solid rgba(0, 246, 255, 0.15);
  border-radius: 16px;
  padding: 16px;
  backdrop-filter: blur(10px);
  box-shadow: 0 8px 24px rgba(0,0,0,0.5);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}
.card:hover { transform: translateY(-2px); box-shadow: 0 12px 28px rgba(0,0,0,0.7); }
canvas { width: 100%; height: 320px; background: linear-gradient(#0b0f14, #0a1019); border-radius: 12px; }
.kbd { background: rgba(10, 18, 28, 0.8); border: 1px solid #2b3f5f; color: #9fc5ff; padding: 2px 6px; border-radius: 6px; font-size: 12px; }

.stat { font-size: 28px; font-weight: 800; color: #ffffff; text-shadow: 0 0 4px rgba(0, 200, 255, 0.8); }
.ok { color: #9effb5; } .warn { color: #ffd18f; } .bad { color: #ff9b9b; }

button, .btn-primary {
  background: linear-gradient(135deg, #00c6ff, #0072ff);
  color: #fff; border: none; border-radius: 12px; padding: 10px 16px; font-size: 15px; font-weight: 600;
  transition: background 0.3s ease, transform 0.1s ease;
}
button:hover, .btn-primary:hover { background: linear-gradient(135deg, #0072ff, #00c6ff); transform: translateY(-1px); }

#overlay {
  position: fixed; inset: 0; display: flex; align-items: center; justify-content: center;
  background: rgba(0, 0, 0, 0.6); backdrop-filter: blur(8px); z-index: 9999;
}
#overlay.hide { display: none; }

.title { font-size: 1.4rem; font-weight: 600; margin-bottom: 4px; color: #00f6ff; }
.subtitle { font-size: 0.9rem; color: #9fc5ff; margin-bottom: 16px; }
.form-label { display: block; font-size: 0.85rem; margin-bottom: 12px; text-align: left; font-weight: 500; color: #cceaff; }
.form-input {
  width: 95%; padding: 8px 10px; font-size: 0.9rem; border: 1px solid rgba(0, 246, 255, 0.3); border-radius: 8px;
  margin-top: 4px; background: rgba(10, 18, 28, 0.6); color: #e7f0ff;
}
.form-input:focus { border-color: #00f6ff; outline: none; }
.kbd-info { margin: 16px 0; font-size: 0.85rem; color: #9fc5ff; }
.mobile-control-guide { display: none; font-size: 14px; color: #9fc5ff; background: rgba(18, 24, 38, 0.7);
  border: 1px solid rgba(0, 246, 255, 0.2); padding: 8px 12px; border-radius: 8px; margin-bottom: 12px; }
@media (max-width: 768px){ .mobile-control-guide { display: block; } }

.tasc-toggle {
  position: absolute; top: 12px; right: 16px; display: flex; align-items: center; gap: 6px; z-index: 1001;
}
.tasc-toggle .tasc-label { font-size: 12px; font-weight: 600; color: #9fc5ff; user-select: none; }
.tasc-toggle input { display: none; }
.tasc-toggle .slider {
  position: relative; display: inline-block; width: 46px; height: 24px; background-color: rgba(255,255,255,0.25);
  border-radius: 24px; cursor: pointer; transition: background-color 0.3s; box-shadow: inset 0 0 4px rgba(0,0,0,0.3);
}
.tasc-toggle .slider::before {
  content: ""; position: absolute; height: 18px; width: 18px; left: 3px; bottom: 3px; background-color: white;
  border-radius: 50%; transition: transform 0.3s; box-shadow: 0 1px 3px rgba(0,0,0,0.4);
}
.tasc-toggle input:checked + .slider { background: linear-gradient(135deg, #00c6ff, #0072ff); }
.tasc-toggle input:checked + .slider::before { transform: translateX(22px); }

.fab { position: fixed; left: 50%; bottom: 24px; transform: translateX(-50%); padding: 12px 18px; font-weight: 700;
  border-radius: 999px; background: linear-gradient(135deg, #00c6ff, #0072ff); color: #fff; border: none; z-index: 10000; box-shadow: 0 8px 24px rgba(0,0,0,0.35); }
.fab.hide { display: none; }
footer { text-align:center; font-size:12px; color:#888; padding:8px 0; user-select:none; }
</style>
</head>
<body>
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">
    <div class="mobile-control-guide">
      ğŸ“± <b>ëª¨ë°”ì¼ ì¡°ì‘ ì•ˆë‚´:</b> ê·¸ë˜í”„ ìœ„ë¥¼ í„°ì¹˜í•˜ì„¸ìš”. ìœ„ìª½ í„°ì¹˜ â†’ ë¸Œë ˆì´í¬ ê°•í™” ğŸ”¼ / ì•„ë˜ìª½ í„°ì¹˜ â†’ ì™„í™” ğŸ”½
    </div>

    <div class="card" style="flex:1 1 260px">
      <div id="carName" style="font-size:20px" class="stat">ì°¨ëŸ‰ ë¡œë”© ì¤‘...</div>
      <div>ë‚¨ì€ ê±°ë¦¬ <span class="stat" id="rem">â€”</span> m</div>
      <div>ì†ë„ <span class="stat" id="spd">â€”</span> km/h</div>
      <div>ë…¸ì¹˜ <span class="stat" id="notch">N</span></div>
      <div>êµ¬ë°° <span class="stat" id="grade_percent">â€”</span> %</div>
      <div>Î¼ <span class="stat" id="muStat">â€”</span> / rr<span class="stat" id="rrStat">â€”</span></div>
      <div style="margin-top:8px">ì¡°ì‘: <span class="kbd">Space</span> ì‹œì‘ Â· <span class="kbd">W</span> ë¸Œë ˆì´í¬â†‘ Â· <span class="kbd">S</span> ë¸Œë ˆì´í¬â†“ Â· <span class="kbd">N</span> í•´ë°©</div>
    </div>

    <div class="card" style="flex:2 1 520px">
      <canvas id="hud"></canvas>
      <div style="font-size:12px;color:#9fc5ff;margin-top:6px" id="legend">
        â€”
      </div>
    </div>

    <div class="card" style="flex:1 1 240px">
      <div><b>í”¼ë“œë°±</b></div>
      <div id="fb">Spaceë¥¼ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”.</div>
    </div>
  </div>
</div>

<!-- Overlay -->
<div id="overlay">
  <div class="card" style="position:relative; width:320px; max-width:90vw;">
    <!-- TASC í† ê¸€ -->
    <div class="tasc-toggle">
      <input type="checkbox" id="tascToggle" />
      <label for="tascToggle" class="slider"></label>
      <span class="tasc-label">TASC</span>
    </div>

    <h2 class="title">ğŸš‰ TASC ê¸°ë°˜ ì •ì°¨ íŠ¸ë ˆì´ë„ˆ</h2>
    <p class="subtitle">ì´ˆê¸°ê°’ì„ ì…ë ¥í•˜ê³  TASC(ì˜¤í† íŒŒì¼ëŸ¿) ë²„íŠ¼ì„ ì¼œê±°ë‚˜ ëˆ ë’¤ <b>Space</b> ë˜ëŠ” ì•„ë˜ ë²„íŠ¼ì„ ëˆŒëŸ¬ ì‹œì‘í•˜ì„¸ìš”.</p>

    <label class="form-label">ì´ˆê¸° ì†ë„ (km/h)
      <input id="inputSpeed" type="number" value="90" min="20" max="130" step="5" class="form-input">
    </label>
    <label class="form-label">ê±°ë¦¬ (m)
      <input id="inputDist" type="number" value="500" min="100" max="1500" step="50" class="form-input">
    </label>
    <label class="form-label">ê²½ì‚¬ë„ (%)
      <input id="inputGrade" type="number" value="0.0" min="-40" max="40" step="0.5" class="form-input">
    </label>
    <label class="form-label">ë‚ ì”¨
      <select id="weatherSelect" class="form-input">
        <option value="ë§‘ìŒ">ë§‘ìŒ</option>
        <option value="ë¹„ì˜´">ë¹„ì˜´</option>
        <option value="ëˆˆì˜´">ëˆˆì˜´</option>
      </select>
    </label>
    <label class="form-label">ìŠ¹ê° íƒ‘ìŠ¹ë¥  (%)
      <input id="inputLoadRate" type="number" value="70" min="0" max="120" step="1" class="form-input">
    </label>
    <label class="form-label">í¸ì„±
      <select class="form-input" id="trainLength">
        <option value="4">4ëŸ‰</option>
        <option value="6" selected>6ëŸ‰</option>
        <option value="8">8ëŸ‰</option>
        <option value="10">10ëŸ‰</option>
        <option value="12">12ëŸ‰</option>
        <option value="15">15ëŸ‰</option>
      </select>
    </label>

    <div class="kbd-info">
      <span class="kbd">W</span> ë¸Œë ˆì´í¬ ê°•í™” Â· <span class="kbd">S</span> ì™„í™” Â· <span class="kbd">N</span> í•´ë°©
    </div>
    <button id="btnStart" class="btn-primary">Start (Space)</button>
  </div>
</div>

<button id="btnMobileRestart" class="fab hide">ì¬ì‹œì‘</button>

<script>
// ========= WS =========
const ws = new WebSocket((location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws");

// UI refs
const tascToggle = document.getElementById("tascToggle");
const weatherSelect = document.getElementById("weatherSelect");
const inputSpeed = document.getElementById("inputSpeed");
const inputDist = document.getElementById("inputDist");
const inputGrade = document.getElementById("inputGrade");
const trainLengthSel = document.getElementById("trainLength");
const btnStart = document.getElementById("btnStart");
const overlay = document.getElementById("overlay");
const btnMobileRestart = document.getElementById("btnMobileRestart");

const carNameEl = document.getElementById("carName");
const remEl = document.getElementById("rem");
const spdEl = document.getElementById("spd");
const notchEl = document.getElementById("notch");
const gradeEl = document.getElementById("grade_percent");
const muStat = document.getElementById("muStat");
const rrStat = document.getElementById("rrStat");
const fb = document.getElementById("fb");
const legend = document.getElementById("legend");

// HUD
const canvas = document.getElementById("hud");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width=canvas.clientWidth*devicePixelRatio; canvas.height=canvas.clientHeight*devicePixelRatio; }
addEventListener("resize", resize); resize();

// ===== Helpers =====
function muFromWeather(w) {
  if (w === "ë¹„ì˜´") return 0.6;
  if (w === "ëˆˆì˜´") return 0.3;
  return 1.0;
}
function sendCmd(name, delta){
  if (ws.readyState === WebSocket.OPEN) ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
}
function startRun(){
  const speed = Number(inputSpeed.value);
  const dist  = Number(inputDist.value);
  const grade = Number(inputGrade.value);
  const mu = muFromWeather(weatherSelect.value);
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setInitial", speed, dist, grade, mu } }));
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "start" }}));
  }
  overlay.classList.add("hide");
  isFinished = false;
}
btnStart.addEventListener("click", startRun);

tascToggle.addEventListener("change", () => {
  const enabled = tascToggle.checked;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled } }));
  }
});
function forceManualOverride(){
  if (tascToggle.checked) {
    tascToggle.checked = false;
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled: false } }));
    }
  }
}

// íƒ‘ìŠ¹ë¥  â†’ ì¤‘ëŸ‰ ë°˜ì˜
function sendLoadRate(){
  const loadRate = parseFloat(document.getElementById("inputLoadRate").value) || 0;
  const trainLength = parseInt(trainLengthSel.value) || 8;
  const baseMassPerCar = 39.9;
  const maxPassengerMassPerCar = 10.5;
  const totalMassTons = trainLength * (baseMassPerCar + maxPassengerMassPerCar * (loadRate / 100));
  ws.send(JSON.stringify({ type: "cmd", payload: { name: "setMassTons", mass_tons: totalMassTons, length: trainLength }}));
  console.log(`ì´ ì¤‘ëŸ‰: ${totalMassTons.toFixed(2)} t`);
}
trainLengthSel.addEventListener("change", ()=>{
  const length = parseInt(trainLengthSel.value)||8;
  ws.send(JSON.stringify({ type:"cmd", payload:{ name:"setTrainLength", length }}));
  sendLoadRate();
});
document.getElementById("inputLoadRate").addEventListener("change", sendLoadRate);

weatherSelect.addEventListener("change", ()=>{
  const mu = muFromWeather(weatherSelect.value);
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type:"cmd", payload:{ name:"setMu", value: mu } }));
  }
});

// í‚¤ë³´ë“œ
addEventListener("keydown", (e)=>{
  if ([" ", "w","W","s","S","n","N"].includes(e.key)) e.preventDefault();
  if (e.repeat) return;
  forceManualOverride();
  if (e.key === " "){
    if (overlay.classList.contains("hide")){
      const speed = Number(inputSpeed.value);
      const dist  = Number(inputDist.value);
      const grade = Number(inputGrade.value);
      const mu    = muFromWeather(weatherSelect.value);
      ws.send(JSON.stringify({ type:"cmd", payload:{ name:"setInitial", speed, dist, grade, mu }}));
      ws.send(JSON.stringify({ type:"cmd", payload:{ name:"start" }}));
      isFinished = false;
    }else{
      overlay.classList.add("hide");
      startRun();
    }
  }else if (e.key === "w" || e.key === "W"){ sendCmd("applyNotch", +1); }
  else if (e.key === "s" || e.key === "S"){ sendCmd("applyNotch", -1); }
  else if (e.key === "n" || e.key === "N"){ sendCmd("release", 0); }
});

// ëª¨ë°”ì¼ í„°ì¹˜
if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
  canvas.addEventListener("touchstart", (e)=>{
    if (!overlay.classList.contains("hide")) return;
    if (e.touches.length !== 1) return;
    forceManualOverride();
    const rect = canvas.getBoundingClientRect();
    const y = e.touches[0].clientY - rect.top;
    const half = rect.height / 2;
    if (y < half) sendCmd("applyNotch", +1); else sendCmd("applyNotch", -1);
  }, { passive: true });
}
btnMobileRestart.addEventListener("click", ()=>{
  overlay.classList.remove("hide");
  btnMobileRestart.classList.add("hide");
});

// ===== HUD ë¬¼ë¦¬ ê³„ì‚° =====
let st = null;
let isFinished = false;

function drawHUD(st){
  const dpr = devicePixelRatio || 1, w = canvas.width, h = canvas.height;
  ctx.clearRect(0,0,w,h);

  // ì¶• ì˜ì—­
  const leftMargin = 54*dpr, rightMargin = 14*dpr, bottomMargin = 28*dpr, topMargin = 12*dpr;
  const usableWidth = w - leftMargin - rightMargin;
  const usableHeight = h - bottomMargin - topMargin;

  const v0 = st.v; // m/s
  const v0_kmh = v0*3.6;
  const L = st.L;
  const rem = Math.max(0, st.remaining_m ?? L);

  // ì°¨ëŸ‰/ê³„ìˆ˜
  const veh = st.veh || {};
  const mass_kg = veh.mass_kg || 200000;
  const C_rr = veh.C_rr ?? 0.005;
  const rho = veh.rho_air ?? 1.225;
  const Cd = veh.Cd ?? 1.8;
  const A = veh.A ?? 10.0;
  const notches = veh.notches || 9;
  const baseAccels = veh.notch_accels || []; // ìŒìˆ˜(ê°ì†), 0..EB

  const mu = st.mu ?? 1.0;
  const rr_factor = st.rr_factor ?? 1.0;

  const k_srv = st.adhesion?.k_srv ?? 0.7;
  const k_eb  = st.adhesion?.k_eb ?? 0.9;
  const alpha_eff = st.adhesion?.alpha_eff ?? 0.2;

  // ê²½ì‚¬/ì €í•­ ê³„ìˆ˜
  const g = 9.81;
  const grade_percent = st.grade_percent || 0.0;
  const a_grade = (-g * (grade_percent/100.0))/10.0; // ì„œë²„ì™€ ë™ì¼ ë³´ì •
  const Crr_eff = C_rr * rr_factor;
  const K_drag = 0.5 * rho * Cd * A / mass_kg; // a_drag = -K_drag * v^2

  // ê·¸ë˜í”„ ìŠ¤ì¼€ì¼
  const vmax_kmh = Math.max(20, v0_kmh*1.2);
  const vmax = vmax_kmh; // km/h ìŠ¤ì¼€ì¼
  const s_max_guess = Math.max(rem*1.2, 100); // ê¸°ë³¸ xë²”ìœ„
  // ë™ì  maxDistance: EBë¡œ 0ê¹Œì§€ ìˆ˜ì¹˜ì ë¶„í•˜ì—¬ ì–»ì€ ì •ì§€ê±°ë¦¬ ë“±ìœ¼ë¡œ ê°±ì‹ 
  const ebIndex = notches - 1;

  // ì¢Œí‘œ ë³€í™˜
  const X = dist => leftMargin + usableWidth * (dist / s_max_guess);
  const Y = v_kmh => (h - bottomMargin) - usableHeight * (v_kmh / vmax);

  // ì¶•/ëˆˆê¸ˆ
  ctx.strokeStyle = "#20334d"; ctx.lineWidth = 1*dpr;
  ctx.beginPath(); ctx.moveTo(leftMargin, topMargin); ctx.lineTo(leftMargin, h-bottomMargin); ctx.lineTo(w-rightMargin, h-bottomMargin); ctx.stroke();
  ctx.fillStyle = "#88a"; ctx.font = `${10*dpr}px sans-serif`; ctx.textAlign="center"; ctx.textBaseline="top";
  for(let dist=0; dist<=s_max_guess; dist+=100){
    const x = X(dist); ctx.beginPath(); ctx.moveTo(x, h-bottomMargin); ctx.lineTo(x, h-bottomMargin+4*dpr); ctx.stroke(); ctx.fillText(`${Math.round(dist)}`, x, h-bottomMargin+6*dpr);
  }
  ctx.textAlign="right"; ctx.textBaseline="middle";
  for(let sp=0; sp<=vmax; sp+=10){
    const y = Y(sp); ctx.beginPath(); ctx.moveTo(leftMargin-4*dpr, y); ctx.lineTo(leftMargin, y); ctx.stroke(); ctx.fillText(`${sp}`, leftMargin-6*dpr, y);
  }

  // ë¸Œë ˆì´í¬ ê³¡ì„ : ìˆ˜ì¹˜ì ë¶„
  function effFromMu(mu){ return 1.0 - alpha_eff*(1.0 - Math.max(0, Math.min(1, mu))); }
  function aBrakeForNotch(notch){
    const base = baseAccels[notch] ?? 0; // ìŒìˆ˜ ë˜ëŠ” 0
    const eff = effFromMu(mu);
    const a_equipment = base * eff;
    const k = (notch === ebIndex) ? k_eb : k_srv;
    const a_cap = -k * mu * g;
    return Math.max(a_equipment, a_cap); // ìŒìˆ˜/0
  }
  function aTotal(v, notch){
    // v: m/s
    const a_br = aBrakeForNotch(notch);
    const a_rr = (v>0? -g*Crr_eff : (v<0? g*Crr_eff : 0));
    const a_drag = v>0 ? -K_drag * v * v : 0;
    return a_br + a_grade + a_rr + a_drag;
  }
  function integrateCurve(v0, notch, ds=1.0, sLimit=2000){
    let s=0, v=v0; const pts=[];
    for(let i=0;i<10000;i++){
      if (s > sLimit) break;
      pts.push([s, v*3.6]); // km/hë¡œ ì €ì¥
      const a = aTotal(v, notch);
      const v2 = v*v + 2*a*ds; // v^2(s+ds) â‰ˆ v^2 + 2 a ds
      if (v2 <= 0){ v=0; s += ds; pts.push([s, 0]); break; }
      v = Math.sqrt(v2);
      s += ds;
    }
    return pts;
  }

  // ì–´ë–¤ ë…¸ì¹˜ë“¤ì„ ê·¸ë¦´ì§€: N ì œì™¸ 1..EB ëª¨ë‘ í‘œì‹œ
  const drawNotches = [];
  for(let n=1; n<notches; n++) drawNotches.push(n);

  // ë™ì  xë²”ìœ„ ì¬ì‚°ì •(EB ì •ì§€ê±°ë¦¬ ê¸°ì¤€)
  const ebPts = integrateCurve(v0, ebIndex, 1.0, 5000);
  const ebStopS = ebPts.length? ebPts[ebPts.length-1][0] : 0;
  const maxDistance = Math.max(rem*1.2, ebStopS*1.1, 100);
  const X2 = dist => leftMargin + usableWidth * (dist / maxDistance);

  // ë‹¤ì‹œ ì¶• ëˆˆê¸ˆ(ê±°ë¦¬ë§Œ ì¬í‘œì‹œ)
  ctx.fillStyle="#88a"; ctx.textAlign="center"; ctx.textBaseline="top";
  for(let dist=0; dist<=maxDistance; dist+=100){
    const x = X2(dist);
    ctx.beginPath(); ctx.moveTo(x, h-bottomMargin); ctx.lineTo(x, h-bottomMargin+4*dpr); ctx.stroke();
    ctx.fillText(`${Math.round(dist)}`, x, h-bottomMargin+6*dpr);
  }

  // ê³¡ì„  ê·¸ë¦¬ê¸°
  drawNotches.forEach((notch)=>{
    const pts = integrateCurve(v0, notch, 1.0, Math.max(maxDistance, 1000));
    ctx.beginPath();
    ctx.lineWidth = (notch === st.lever_notch) ? 2.5*dpr : 1.5*dpr;
    ctx.strokeStyle = (notch === st.lever_notch) ? "#ffae00" : "#3fa9ff";
    for(let i=0;i<pts.length;i++){
      const x = X2(pts[i][0]);
      const y = Y(pts[i][1]);
      if (i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    // ë¼ë²¨
    const last = pts[Math.min(pts.length-1, 1)];
    const tx = X2(Math.min(pts[pts.length-1]?.[0]||0, maxDistance));
    ctx.fillStyle = (notch === st.lever_notch) ? "#ffae00" : "#3fa9ff";
    ctx.font = `${11*dpr}px 'Orbitron', sans-serif`;
    const label = (notch === ebIndex) ? "EB" : `B${notch}`;
    ctx.fillText(label, tx + 6*dpr, Y(0) + 12*dpr);
  });

  // ë‚¨ì€ ê±°ë¦¬ ë¹¨ê°„ì„ 
  const x_red = X2(rem);
  ctx.strokeStyle = "#ff4141"; ctx.lineWidth = 1.8*dpr;
  ctx.beginPath(); ctx.moveTo(x_red, Y(0)); ctx.lineTo(x_red, Y(vmax)); ctx.stroke();
  ctx.fillStyle="#ff7676"; ctx.font = `${12*dpr}px 'Orbitron', sans-serif`; ctx.textAlign="center";
  ctx.fillText("ë‚¨ì€ ê±°ë¦¬", x_red, Y(vmax)-16*dpr);

  // ë ˆì „ë“œ/ìƒíƒœ
  legend.textContent =
    `Î¼=${mu.toFixed(2)}, rr_factor=${rr_factor.toFixed(2)}, k_srv=${k_srv.toFixed(2)}, k_eb=${k_eb.toFixed(2)}, grade=${grade_percent.toFixed(2)}%, `
    + `Crr=${C_rr}, Cd=${Cd}, A=${A}, mass=${(mass_kg/1000).toFixed(1)}t`;

} // drawHUD

// ===== WS ìˆ˜ì‹  =====
ws.onmessage = (ev)=>{
  const msg = JSON.parse(ev.data);
  if (msg.type !== "state") return;
  st = msg.payload;

  carNameEl.textContent = st.veh?.name || "EMU";
  const remRaw = st.remaining_m; const rem = typeof remRaw === "number" ? remRaw : parseFloat(remRaw);
  remEl.textContent = rem>=0 ? rem.toFixed(2) : `-${Math.abs(rem).toFixed(2)}`;
  spdEl.textContent = (st.v*3.6).toFixed(1);

  function notchText(n, maxN){ if (n===0) return "N"; if (n===maxN) return "EB"; return `B${n}`; }
  notchEl.textContent = notchText(st.lever_notch, (st.veh?.notches||9)-1);

  gradeEl.textContent = (st.grade_percent ?? 0).toFixed(2);
  muStat.textContent = (st.mu ?? 1).toFixed(2);
  rrStat.textContent = (st.rr_factor ?? 1).toFixed(2);

  drawHUD(st);

  if (st.finished){
    isFinished = true;
    const issues = st.issues || {};
    const feedbackItems = [
      { key: "early_brake_too_short", goodText: "ì´ˆê¸° ì œë™ ìˆ˜í–‰ - ìŠ¹ì°¨ê° ì–‘í˜¸", badText: "ì´ˆê¸° ì œë™ ë¶€ì¡± - ìŠ¹ì°¨ê° ë¶ˆì¾Œ" },
      {
        key: "stop_not_b1",
        goodText: "ì •ì°¨ ì‹œ B1 - ìŠ¹ì°¨ê° ì–‘í˜¸",
        badText: issues.stop_not_b1_msg || "ì •ì°¨ ì‹œ B1 ì•„ë‹˜",
      },
      {
        key: "step_brake_incomplete",
        goodText: "ê³„ë‹¨ì œë™/ì™„í•´ ìˆ˜í–‰",
        badText: (issues.stop_error_m !== undefined && issues.stop_error_m <= -2)
          ? "ê³„ë‹¨ì œë™ ë¯¸í¡ - ì •ì°¨ ìœ„ì¹˜ ì´ˆê³¼"
          : "ê³„ë‹¨ì œë™ ë¯¸í¡ - ìŠ¹ê° ì ë¦¼/ì§„ë™",
      },
      { key: "unnecessary_eb_usage", goodText: "ì˜ì—… ì•ˆì „ ì œë™ë²”ìœ„ ì¤€ìˆ˜", badText: "ë¶ˆí•„ìš”í•œ EB ì‚¬ìš©" },
    ];
    const feedbacks = feedbackItems.map(it=>{
      const bad = issues[it.key]; if (!bad) return { text: it.goodText, ok:true };
      return { text: it.badText, bad:true };
    });
    const stopErr = st.stop_error_m ?? 0;
    const isStopOk = Math.abs(stopErr) <= 2;
    feedbacks.push({ text:`ì •ì§€ ì˜¤ì°¨: ${stopErr.toFixed(2)} m`, ok:isStopOk });
    feedbacks.push({ text:`ìµœì¢… ì ìˆ˜: ${st.score}ì `, ok:isStopOk });

    fb.innerHTML = feedbacks.map(x => x.bad
      ? `<div class="bad">${x.text}</div>`
      : `<div class="${x.ok?"ok":"warn"}">${x.text}</div>`
    ).join("") + `<div style="margin-top:8px;font-size:12px;color:#a6b7d1">Spaceë¡œ ë‹¤ì‹œ ì‹œì‘ Â· N í•´ë°© Â· W/Së¡œ ì¡°ì‘</div>`;

    if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
      btnMobileRestart.classList.remove("hide");
    }
  }else{
    isFinished = false;
    fb.textContent = "Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.";
  }
};

// ë Œë” ë£¨í”„(ë¶€ë“œëŸ¬ìš´ ë¦¬ì‚¬ì´ì¦ˆìš©)
let lastTS=0;
function loop(ts){ if (!lastTS) lastTS=ts; lastTS=ts; if (st) drawHUD(st); requestAnimationFrame(loop); }
requestAnimationFrame(loop);
</script>

<footer>Â©2025 Hyungsuk Choi, University of Maryland</footer>
</body>
</html>