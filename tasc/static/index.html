<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1, user-scalable=no"/>
  <title>TASC Simulator</title>
  <link rel="icon" href="/static/favicon.ico" type="image/x-icon">
  <link rel="shortcut icon" href="/static/favicon.ico" type="image/x-icon">

  <!-- Google Fonts: Noto Sans JP Bold -->
  <link href="https://fonts.cdnfonts.com/css/a-otf-shin-go-pro" rel="stylesheet">
<style>
@import url('https://fonts.cdnfonts.com/css/a-otf-shin-go-pro');

html, body {
  margin: 0;
  background: radial-gradient(circle at 50% 20%, #0b0f14, #05070a);
  background-attachment: fixed;
  color: #e7f0ff;
  font-family: 'Orbitron', system-ui, Segoe UI, Roboto, Apple SD Gothic Neo, AppleGothic, sans-serif;
}
.game-background,.snow-background,.rain-background{background:transparent!important}
#wrap{max-width:960px;margin:18px auto;padding:0 12px}
.row{display:flex;gap:12px;align-items:center}
.card{
  background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.15);border-radius:16px;padding:16px;
  backdrop-filter:blur(10px);box-shadow:0 8px 24px rgba(0,0,0,.5);transition:transform .2s,box-shadow .2s
}
.card:hover{transform:translateY(-2px);box-shadow:0 12px 28px rgba(0,0,0,.7)}
canvas{width:100%;height:320px;background:linear-gradient(#0b0f14,#0a1019);border-radius:12px}
.kbd{background:rgba(10,18,28,.8);border:1px solid #2b3f5f;color:#9fc5ff;padding:2px 6px;border-radius:6px;font-size:12px}
.stat{font-size:32px;font-weight:800;color:#fff;text-shadow:0 0 4px rgba(0,200,255,.8)}
.ok{color:#9effb5}.warn{color:#ffd18f}.bad{color:#ff9b9b}
button,.btn-primary{background:linear-gradient(135deg,#00c6ff,#0072ff);color:#fff;border:none;border-radius:12px;padding:10px 16px;font-size:15px;font-weight:600;transition:.3s background,.1s transform}
button:hover,.btn-primary:hover{background:linear-gradient(135deg,#0072ff,#00c6ff);transform:translateY(-1px)}
#overlay {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(0,0,0,.6);
  backdrop-filter: blur(8px);
  z-index: 9999;
  overflow-y: auto;
  -webkit-overflow-scrolling: touch;
}

/* ğŸ’» ë°ìŠ¤í¬íƒ‘ ì „ìš© (768px ì´ˆê³¼ ì‹œ) */
@media (min-width: 769px) {
  #overlay {
    inset: auto;       /* ì „ì²´ ë®ëŠ” ëŒ€ì‹  */
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;

    justify-content: center;
    align-items: flex-start;
    padding-top: 40px; /* ì‚´ì§ ì—¬ë°± */
  }
  #overlay .card {
    width: 720px;      /* ì›í•˜ëŠ” fixed width */
    max-height: 90vh;  /* ì„¸ë¡œëŠ” ìŠ¤í¬ë¡¤ í—ˆìš© */
  }
}

#overlay.hide{display:none}
#overlay .card{max-height:90vh;overflow-y:auto}
.title{font-size:1.4rem;font-weight:600;margin-bottom:4px;color:#00f6ff}
.subtitle{font-size:.9rem;color:#9fc5ff;margin-bottom:16px}
.form-label{display:block;font-size:.85rem;margin-bottom:12px;text-align:left;font-weight:500;color:#cceaff}
.form-input{width:100%;box-sizing:border-box;padding:8px 10px;font-size:.9rem;border:1px solid rgba(0,246,255,.3);border-radius:8px;margin-top:4px;background:rgba(10,18,28,.6);color:#e7f0ff}
.form-input:focus{border-color:#00f6ff;outline:none}
@keyframes snow{0%{transform:translateY(-20px)}100%{transform:translateY(100vh)}}
.snowflakes,.raindrops{position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:9999;display:none;overflow:hidden}
.snowflakes div{position:absolute;background:#fff;width:10px;height:10px;border-radius:50%;opacity:.8;animation:snow 5s linear infinite}
.raindrops{z-index:9998}
.raindrops div{position:absolute;background:rgba(173,216,230,.8);width:2px;height:15px;animation:rain .5s linear infinite}
@keyframes rain{0%{transform:translateY(-20px)}100%{transform:translateY(100vh)}}
body{overflow-x:hidden;overflow-y:auto}
@media (max-width:768px){html,body{height:100%}body{-webkit-overflow-scrolling:touch}#wrap{padding-bottom:96px}canvas#hud{height:42vh}}
/* Hide large right ribbon on mobile for space and performance */
@media (max-width:768px){
  #ribbonBig{display:none !important}
}
/* ì¬ì‹œì‘ FAB â€“ ìµœìƒë‹¨, í´ë¦­ í™•ì‹¤í•˜ê²Œ */
.fab{
  position:fixed;left:50%;bottom:24px;transform:translateX(-50%);padding:12px 18px;font-weight:700;border-radius:999px;
  background:linear-gradient(135deg,#00c6ff,#0072ff);color:#fff;border:none;z-index:10001;
  box-shadow:0 8px 24px rgba(0,0,0,.35);cursor:pointer;pointer-events:auto
}
.fab.hide{display:none}
.fab:hover{background:linear-gradient(135deg,#0072ff,#00c6ff);transform:translateX(-50%) translateY(-1px)}
.mobile-control-guide{display:none;font-size:14px;color:#9fc5ff;background:rgba(18,24,38,.7);border:1px solid rgba(0,246,255,.2);padding:8px 12px;border-radius:8px;margin-bottom:12px}
@media (max-width:768px){.mobile-control-guide{display:block}}
/* TASC í† ê¸€ â€“ ì‚´ì§ ì•„ë˜ */
.tasc-toggle {
  position: absolute;
  right: 16px;
  display: flex;
  align-items: center;
  gap: 6px;
  font-family: 'Orbitron', sans-serif;
  z-index: 1001;
  top: 40px;
}
@media (max-width: 768px) {.tasc-toggle {top: 165px;}}
.tasc-toggle .tasc-label{font-size:12px;font-weight:600;color:#9fc5ff;user-select:none}
.tasc-toggle input{display:none}
.tasc-toggle .slider{position:relative;display:inline-block;width:46px;height:24px;background:rgba(255,255,255,.25);border-radius:24px;cursor:pointer;transition:background-color .3s;box-shadow:inset 0 0 4px rgba(0,0,0,.3)}
.tasc-toggle .slider::before{content:"";position:absolute;height:18px;width:18px;left:3px;bottom:3px;background:#fff;border-radius:50%;transition:transform .3s;box-shadow:0 1px 3px rgba(0,0,0,.4)}
.tasc-toggle input:checked + .slider{background:linear-gradient(135deg,#00c6ff,#0072ff)}
.tasc-toggle input:checked + .slider::before{transform:translateX(22px)}

.emoji { width: 1.4em; height: 1.4em; vertical-align: middle; transition: transform 0.2s;}
.emoji:hover { transform: scale(1.3);}

.title { font-size: 1.7em; font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal; font-weight: 700; color: #0168B7; display: flex; align-items: center; gap: 8px;}

.line {
  display: flex;
  justify-content: space-between;
  align-items: baseline;
  margin: 4px 0;
}
.line .value {
  text-align: right;
  padding-right: 40px;  /* ğŸ‘ˆ ì˜¤ë¥¸ìª½ì— ì—¬ë°± ì£¼ê¸° (ë¼ë”ìº”ë²„ìŠ¤+ê°„ê²©) */
  min-width: 100px;     /* ğŸ‘ˆ ìˆ«ì ì¹¸ ìµœì†Œ ë„ˆë¹„ ì¡ì•„ì£¼ë©´ ë” ì•ˆì •ì  */
}
.line .unit {
  margin-left: 4px;
  opacity: 0.8;
  font-size: 14px;
  letter-spacing:-2px;
}

#timer .sep {
  margin: 0 8px; /* ì½œë¡  ì¢Œìš° ê°„ê²©ë§Œ ì¡°ì • */
}

@media (max-width:768px){
  .line .value { padding-right: 50px; }
}

#hud, #brakeLadder {
  touch-action: none; /* iOS 13+ / ìµœì‹  ì‚¬íŒŒë¦¬ */
  -ms-touch-action: none;
  user-select: none;
  -webkit-user-select: none;
  -webkit-touch-callout: none;
}

</style>
</head>
<body>
<canvas id="ribbonBig" style="position:fixed; right:0; top:0; bottom:0; width:27px; height:100vh; pointer-events:none; z-index:10002; display:flex; align-items:right; justify-content:center;"></canvas>
<!-- BEGIN PATCH: Cab 3D Card -->
<style>
/* Make the cab card tighter so the 3D view fills it with minimal padding */
#cabCard {
  padding: 2px 4px !important;
  margin: 0 !important;
  box-sizing: border-box;
  min-width: 0;
  align-items: stretch;
  /* display: fle/; Flex/ox layout to stretch the child */
}

#cabCard > #cab3d {
  width: 50% !important;  /* Use full width of the parent */
  margin: 0 !important;
  padding: 0 !important;
  aspect-ratio: 16/9 !important;
  border-radius: 6px !important;
  box-sizing: border-box !important;
  display: block;
}

/* Slightly different spacing on very small screens */
@media (max-width: 480px) {
  #cabCard { padding: 4px !important; }
  #cabCard > #cab3d { border-radius: 4px !important; }
}
</style>

<script>
/* Defensive runtime enforcement to override any inline width:50% */
(function(){
  const cab = document.getElementById('cab3d');
  const cabCard = document.getElementById('cabCard');
  if (cabCard) cabCard.style.padding = '2px 4px';
  if (cab) {
    cab.style.width = '100%';  /* Ensure 3D view takes up full available width */
    cab.style.margin = '0';
    cab.style.padding = '0';
    cab.style.boxSizing = 'border-box';
  }
})();
</script>
<div class="card" id="cabCard" style="flex:0 1 auto;" align="center">
  <div id="cab3d" style="background:#000;border-radius:8px;overflow:hidden"></div>
  <div class="hint" style="font-size:12px;color:#9fc5ff;margin-top:6px">
    <!-- 200m ì§€ì ë¶€í„° 50m ê°„ê²©ìœ¼ë¡œ ì°¸ê³  í‘œì§€íŒì´ ì„¤ì¹˜ë˜ì–´ ìˆìŠµë‹ˆë‹¤. -->
  </div>
</div>

<!-- END PATCH: Cab 3D Card -->
<div id="wrap" class="row" style="flex-direction:column">
  <div class="row" style="gap:16px;flex-wrap:wrap">

 <!--   <div class="mobile-control-guide" id="mobileGuide">
      ğŸ“± <b>ëª¨ë°”ì¼ ì¡°ì‘ ì•ˆë‚´:</b> ìº”ë²„ìŠ¤(ê·¸ë˜í”„) ìœ„ë¥¼ í„°ì¹˜í•˜ì„¸ìš”.<br>
      ìœ„ìª½ í„°ì¹˜ â†’ ë¸Œë ˆì´í¬ ê°•í™” ğŸ”¼ / ì•„ë˜ìª½ í„°ì¹˜ â†’ ì™„í™” ğŸ”½<br>
      ì •ì°¨ í›„ ì•„ë˜ í™”ë©´ì—ì„œ í”¼ë“œë°±ì„ í™•ì¸í•˜ì„¸ìš”.
    </div> -->

<div class="card" style="flex:1 1 260px; position: relative">
    
  <div id="carName" style="font-size:20px; font-family: 'A-OTF Shin Go Pro', sans-serif; font-style: normal;" class="stat">ì°¨ëŸ‰ ë¡œë”© ì¤‘...</div>

<div class="line">
  <span id="labelRemainTime">ë‚¨ì€ì‹œê°„</span>
  <span class="stat value" id="timer">
    <span class="min">00</span><span class="sep">:</span><span class="sec">00</span>
  </span>
</div>

<div class="line">
  <span id="labelSpeed">ì†ë„</span>
  <span class="stat value"><span id="spd">â€”</span><span class="unit"> km/h</span></span>
</div>
<div class="line">
  <span id="labelRemainDist">ì •ì°¨</span>
  <span class="stat value" id="rem">â€”</span>
</div>
<div class="line">
  <span id="labelGrade">êµ¬ë°°</span>
  <span class="stat value"><span id="grade_percent">â€”</span><span class="unit"> â€°</span></span>
</div>
<div class="line">
  <span id="labelNotch">ë…¸ì¹˜</span>
  <span class="stat value" id="notch">-</span>
</div>
  <div style="margin-top:8px">
    <!-- <span id="labelControls">ì¡°ì‘:</span> -->
    <span class="kbd">Space</span> <span id="labelStartKey">ì¬ì‹œì‘</span> Â·
    <span class="kbd">W</span> <span id="labelUp">ì œë™ ì²´ê²°</span> Â·
    <span class="kbd">S</span> <span id="labelDown">ì œë™ ì™„í•´</span> Â·
    <span class="kbd">A</span> <span id="labelRestart">6ë‹¨ ìƒìš©ì œë™</span>
    <!-- <span id="labelRelease">í•´ë°©</span> <span class="kbd">N</span> -->
  </div>

  <canvas id="brakeLadder" style="position:absolute; right:10px; top:30px; width:28px; height:70%;"></canvas>
  <!-- í° ìš°ì¸¡ ë¦¬ë³¸: í˜ì´ì§€ ì˜¤ë¥¸ìª½ì— ê³ ì •ë˜ì–´ HUDì˜ ë¦¬ë³¸/ë‹¤ì´ì•„ëª¬ë“œë¥¼ ë” í¬ê²Œ í‘œì‹œí•©ë‹ˆë‹¤ -->
</div>

<div class="card" style="flex:2 1 520px"><canvas id="hud"></canvas></div>
<div class="card" style="flex:1 1 240px"><div><b>í”¼ë“œë°±</b></div><div id="fb">Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.</div></div>
</div>
</div>

<!-- ì˜¤ë²„ë ˆì´ -->
<div id="overlay">
  <div class="card">
    <h2 class="title">
      <img id="trainIcon" src="/static/logos/e233_logo.png" alt="E233" class="emoji"> 
      JR TASC Simulator
    </h2>

    <p class="subtitle" id="subtitleIntro">ì´ˆê¸°ê°’ ì…ë ¥ í›„ <b>TASC(ìë™ì •ì°¨)</b> ì„¤ì •í•˜ê³  <b>Space</b> ë˜ëŠ” ì•„ë˜ ë²„íŠ¼ìœ¼ë¡œ ì‹œì‘í•˜ì„¸ìš”. TASCê°€ í™œì„±í™”ëœ ìƒíƒœì—ì„œë„, ìš´ì „ìëŠ” ìˆ˜ë™ ì¡°ì‘ìœ¼ë¡œ ìš´ì „ì— ê°œì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>

    <!-- TASC -->
    <div class="tasc-toggle">
      <input type="checkbox" id="tascToggle" unchecked />
      <label for="tascToggle" class="slider"></label>
      <span class="tasc-label" id="labelTASC" style="font-weight:700">TASC</span>
    </div>

    <!-- BEGIN PATCH: Overlay - Sync Mode Selector (label ë³€ê²½ë§Œ) -->
<label class="form-label"><span>Graphic</span>
  <select id="syncMode" class="form-input">
    <option value="on" selected>ACTIVATE</option>
    <option value="off" >DEACTIVATE</option>
  </select>
</label>
<!-- END PATCH -->

    <!-- ì „ë™ì°¨ / ì‹œë¦¬ì¦ˆ -->
    <label class="form-label"><span id="labelTrain">ì „ë™ì°¨</span>
      <select id="trainFamily" class="form-input">
        <option value="E233" selected>E233ê³„</option>
        <option value="E235">E235ê³„</option>
        <!-- <option value="JRW223">223ê³„</option>
        <option value="JRW225">225ê³„</option>
        <option value="JRH261">261ê³„</option>
        <option value="JRW285">285ê³„</option>
        <option value="JRW323">323ê³„</option>
        <option value="JR103">103ê³„</option>
        <option value="EF510">EF510í˜• ì „ê¸°ê¸°ê´€ì°¨ + E26ê³„ ê°ì°¨</option>
        <option value="K3000">ì¼€ì´ì„¸ì´ 3000ê³„</option>
        <option value="T5300">ë„ì¿„ë„ êµí†µêµ­ 5300ê³„</option> -->
        <option value="N700S">ì‹ ì¹¸ì„¼ N700Sê³„</option> 
      </select>
    </label>
    <label class="form-label"><span id="labelSeries">ì‹œë¦¬ì¦ˆ</span>
      <select id="trainSeries" class="form-input"></select>
    </label>

    <!-- âœ… ì†ë„/ê±°ë¦¬ ì…ë ¥ ë²”ìœ„ ê°±ì‹ : ì†ë„ 40~130, ê±°ë¦¬ 150~900 -->
    <label class="form-label"><span id="labelInitSpeed">ì´ˆê¸° ì†ë„ (km/h)</span>
      <input id="inputSpeed" type="number" value="60" min="40" max="300" step="1" class="form-input">
    </label>
    <label class="form-label"><span id="labelInitDist">ê±°ë¦¬ (m)</span>
      <input id="inputDist" type="number" value="250" min="150" max="900" step="1" class="form-input">
    </label>
    <label class="form-label"><span id="labelGradeInput">ê²½ì‚¬ë„ (â€°)</span>
      <input id="inputGrade" type="number" value="0.0" min="-10" max="10" step="0.1" class="form-input">
    </label>

    <label class="form-label"><span id="labelWeather">ë‚ ì”¨</span>
      <select id="weatherSelect" class="form-input">
        <option value="ë§‘ìŒ">ë§‘ìŒ</option><option value="ëˆˆì˜´">ê°•ì„¤/ë¹™íŒ</option><option value="ë¹„ì˜´">ìš°ì²œ</option>
      </select>
    </label>
    <label class="form-label"><span id="labelLoadRate">ìŠ¹ê° íƒ‘ìŠ¹ë¥  (%)</span>
      <input id="inputLoadRate" type="number" value="70" min="0" max="120" step="1" class="form-input">
    </label>

    <!-- í¸ì„± (ì‹œë¦¬ì¦ˆë³„ë¡œë§Œ ê³ ì • ë…¸ì¶œ) -->
    <label class="form-label"><span id="labelTrainLength">í¸ì„±</span>
      <select class="form-input" id="trainLength" onchange="updateTrainLength()"></select>
    </label>

    <div class="game-background"></div>
    <div class="snowflakes"></div>
    <div class="raindrops">
      <div style="animation-delay:0s;left:5%"></div><div style="animation-delay:.2s;left:15%"></div>
      <div style="animation-delay:.4s;left:25%"></div><div style="animation-delay:.6s;left:35%"></div>
      <div style="animation-delay:.8s;left:45%"></div><div style="animation-delay:1s;left:55%"></div>
      <div style="animation-delay:1.2s;left:65%"></div><div style="animation-delay:1.4s;left:75%"></div>
      <div style="animation-delay:1.6s;left:85%"></div><div style="animation-delay:1.8s;left:95%"></div>
    </div>

    <div class="kbd-info"><span class="kbd">W</span> ì œë™ ì²´ê²° Â· <span class="kbd">S</span> ì œë™ ì™„í•´ Â· <span class="kbd">N</span> ì¤‘ë¦½ ê¸°ì–´ Â· <span class="kbd">A</span> 6ë‹¨ ìƒìš©ì œë™</div>
    <button id="btnStart" class="btn-primary" type="button" style="margin-top:8px">Start (Space)</button>
  </div>
</div>


<!-- ì¬ì‹œì‘ FAB -->
<button id="btnMobileRestart" class="fab hide" type="button">ì¬ì‹œì‘</button>


<script src="https://unpkg.com/three@0.160.0/build/three.min.js"></script>

<script>

/* ===== WebSocket & TASC ===== */
const ws = new WebSocket((location.protocol==="https:"?"wss://":"ws://")+location.host+"/ws");

const icons = [
  "/static/logos/e233_logo.png",
  "/static/logos/n700s_icon.png",
  "/static/logos/500.png",
  "/static/logos/e7.png",
];
const randIcon = icons[Math.floor(Math.random() * icons.length)];
document.getElementById("trainIcon").src = randIcon;

ws.addEventListener('open', () => {
  // âœ… ë³´ì •í‘œ(IDW) í•œ ë²ˆë§Œ ì„¸íŒ…í•˜ë©´ ì´í›„ ìë™ ì œí•œì‹œê°„ ì‚°ì¶œ
  ws.send(JSON.stringify({
    type: "cmd",
    payload: {
      name: "setTimerCalib",
      points: [
        { v: 40, L: 150, t: 27 },
        { v: 60, L: 200, t: 29 },
        { v: 70, L: 300, t: 32 },
        { v: 90, L: 500, t: 40 },
        { v: 130, L: 900, t: 49 }
      ],
      norm_v: 100,
      norm_L: 300,
      idw_power: 2.0,
      blend_threshold: 1.5
    }
  }));
  // íƒ€ì´ë¨¸ í™œì„±í™”
  ws.send(JSON.stringify({ type: "cmd", payload: { name: "toggleTimer", enabled: true } }));
});

const tascToggle = document.getElementById("tascToggle");
tascToggle.addEventListener("change", () => {
  const enabled = tascToggle.checked;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTASC", enabled } }));
  }
});
// function forceManualOverride(){
//   if (tascToggle.checked){
//     tascToggle.checked=false;
//     if (ws.readyState===WebSocket.OPEN){
//       ws.send(JSON.stringify({type:"cmd",payload:{name:"setTASC",enabled:false}}));
//     }
//   }
// }

/* ===== ë‚ ì”¨ ì´í™íŠ¸ ===== */
const snowflakesContainer=document.querySelector('.snowflakes');
function generateSnowflake(){
  const s=document.createElement('div');
  s.style.animationDelay=(Math.random()*2)+'s';
  s.style.animationDuration=(Math.random()*5+5)+'s';
  s.style.left=Math.floor(Math.random()*101)+'%';
  s.style.position='absolute';s.style.top='-10px';s.style.width='10px';s.style.height='10px';s.style.backgroundColor='rgba(255,255,255,.8)';s.style.borderRadius='50%';
  snowflakesContainer.appendChild(s);
  setTimeout(()=>snowflakesContainer.removeChild(s),7000);
}
setInterval(generateSnowflake,200);

/* ===== Haptics (ëª¨ë°”ì¼) ===== */
const isMobile = /Mobi|Android|iPhone|iPad/i.test(navigator.userAgent);
function canVibrate() { return isMobile && typeof navigator.vibrate === "function" && document.visibilityState === "visible"; }
function vibrate(pattern) { if (!canVibrate()) return false; return navigator.vibrate(pattern) !== false; }
function hapticForNotch(delta) { if (delta !== 0) vibrate([80, 10, 80]); }
function hapticForEB() { vibrate([80, 100, 80]); }

/* ===== ì°¨ëŸ‰ JSON ë¡œë“œ (ìºì‹œ ë¬´ì‹œ) ===== */
let vehicle=null; let brakeDecels={};
const cacheBust=()=>`?v=${Date.now()}`;
// fetch('/static/e233_1000.json'+cacheBust(),{cache:'no-store'})
//   .then(r=>r.json()).then(data=>{
//     vehicle=data; document.getElementById('carName').textContent=vehicle.name;
//     if(vehicle.notch_accels && vehicle.notches){
//       brakeDecels={}; for(let i=0;i<vehicle.notches;i++){ brakeDecels[i]=Math.abs(vehicle.notch_accels[vehicle.notches-1-i]??0); }
//     }
//   }).catch(console.error);

/* ===== DOM ===== */
const remEl=document.getElementById("rem"),
      spdEl=document.getElementById("spd"),
      notchEl=document.getElementById("notch"),
      fb=document.getElementById("fb"),
      timerEl=document.getElementById("timer");
const overlay=document.getElementById("overlay"),
      btnStart=document.getElementById("btnStart"),
      canvas=document.getElementById("hud"),
      ctx=canvas.getContext("2d");

(() => {
  const mount = document.getElementById('cab3d');
  const modeSel = document.getElementById('syncMode');
  const cabCard = document.getElementById('cabCard');

  // ON/OFF â†’ 3D í‘œì‹œ/ìˆ¨ê¹€
  function applyCabToggle(){
    const on = (modeSel?.value === 'on');
    cabCard.style.display = on ? 'block' : 'none';
  }
  modeSel?.addEventListener('change', applyCabToggle);
  applyCabToggle();

  // --- Three.js ê¸°ë³¸ ---
  const scene = new THREE.Scene(); // background will be a canvas gradient for natural sky
  // create a canvas gradient sky and use as scene background texture
  (function(){
    const cw = 1024, ch = 512;
    const cvs = document.createElement('canvas'); cvs.width = cw; cvs.height = ch;
    const cx = cvs.getContext('2d');
    // sky gradient: light near horizon, deep blue above
    const g = cx.createLinearGradient(0,0,0,ch);
    g.addColorStop(0, '#7fb7ff');
    g.addColorStop(0.5, '#9dd1ff');
    g.addColorStop(1, '#16304a');
    cx.fillStyle = g;
    cx.fillRect(0,0,cw,ch);
    // subtle sun glow
    const sx = Math.floor(cw*0.85), sy = Math.floor(ch*0.18);
    const rg = cx.createRadialGradient(sx, sy, 10, sx, sy, 220);
    rg.addColorStop(0, 'rgba(255,250,220,0.85)');
    rg.addColorStop(0.2, 'rgba(255,240,200,0.25)');
    rg.addColorStop(1, 'rgba(255,240,200,0)');
    cx.fillStyle = rg; cx.fillRect(0,0,cw,ch);
    const skyTex = new THREE.CanvasTexture(cvs);
    skyTex.encoding = THREE.sRGBEncoding;
    scene.background = skyTex;
  })();
  // use actual mount size for correct aspect ratio so canvas fills its container
  const initialW = mount.clientWidth || Math.max(800, window.innerWidth);
  const initialH = mount.clientHeight || Math.max(450, Math.round(initialW * 9/16));
  const camera = new THREE.PerspectiveCamera(58, initialW / initialH, 0.1, 2000);


  const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:false });
  renderer.outputColorSpace = THREE.SRGBColorSpace;
  renderer.setPixelRatio(Math.min(window.devicePixelRatio||1, 1));
  mount.appendChild(renderer.domElement);

  function resize(){
    // match renderer/camera to the mount element's actual layout size so the 3D view fills it
    const w = Math.max(16, mount.clientWidth || window.innerWidth);
    const h = Math.max(16, mount.clientHeight || Math.round(w * 9/16));
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
    renderer.setSize(w, h, false);
    // ensure DOM canvas uses full container size (avoid CSS pixel mismatch)
    renderer.domElement.style.width = '100%';
    renderer.domElement.style.height = '100%';
  }
  addEventListener('resize', resize);
  // also observe mount size changes in case layout changes without window resize
  const ro = new ResizeObserver(()=> resize());
  ro.observe(mount);
  resize();

  // --- ë¼ì´íŠ¸: ìì—°ê´‘ + ì†Œí”„íŠ¸ ì„€ë„ìš° (í–‡ë¹› ëŠë‚Œ) ---
  // hemisphere: í•˜ëŠ˜/ì§€ë©´ ìƒ‰ìƒìœ¼ë¡œ ì „ì²´ fillì„ ë¶€ë“œëŸ½ê²Œ í•´ì¤Œ
  const hemi = new THREE.HemisphereLight(0xbfdfff, 0x403020, 0.9);
  scene.add(hemi);

  // directional: íƒœì–‘ê´‘. ì„€ë„ìš°ë¥¼ í™œì„±í™”í•´ì„œ í˜„ì‹¤ê°ì„ ë†’ì¸ë‹¤.
  const dir = new THREE.DirectionalLight(0xfff6e6, 1.0);
  dir.position.set(6, 20, 10);
  dir.castShadow = false;
  dir.shadow.mapSize.width = 1024;
  dir.shadow.mapSize.height = 1024;
  dir.shadow.camera.left = -40;
  dir.shadow.camera.right = 40;
  dir.shadow.camera.top = 40;
  dir.shadow.camera.bottom = -40;
  dir.shadow.camera.near = 1;
  dir.shadow.camera.far = 200;
  dir.shadow.radius = 4;
  scene.add(dir);

  // renderer: ì„€ë„ìš° ì‚¬ìš©
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;

  // --- í…ìŠ¤ì²˜ ë¡œë” ---
  const texLoader = new THREE.TextureLoader();
// --- ì§€ë°˜(ì½˜í¬ë¦¬íŠ¸ ë‹¨ìƒ‰) ---
const groundMat = new THREE.MeshStandardMaterial({
  color: 0x8d8d8d,   // ë°ì€ íšŒìƒ‰ (ì½˜í¬ë¦¬íŠ¸ ëŠë‚Œ)
  roughness: 0.95,   // í‘œë©´ ê±°ì¹ ê¸° ë†’ê²Œ
  metalness: 0.0     // ê¸ˆì†ì„± ì—†ìŒ
});

const ground = new THREE.Mesh(new THREE.PlaneGeometry(12, 1000, 1, 1), groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = 0.0;
ground.position.z = 200;
ground.receiveShadow = true;
ground.castShadow = false;
scene.add(ground);

  // --- íŠ¸ë™ í…ìŠ¤ì²˜(ì¹¨ëª©+ë ˆì¼ì„ í•˜ë‚˜ì˜ í…ìŠ¤ì²˜ë¡œ í•©ì³ì„œ ì²˜ë¦¬) ---
  function createTrackCanvasTexture(){
    // create a tall canvas where vertical axis maps to track length repeat
    const tileW = 1024, tileH = 256; // one tile: across sleepers+rails
    const cvs = document.createElement('canvas'); cvs.width = tileW; cvs.height = tileH;
    const c = cvs.getContext('2d');

    // background: ballast-ish
    c.fillStyle = '#6b6b5f';
    c.fillRect(0,0,tileW,tileH);

    // draw repeated sleepers across width
    const sleeperH = 44; // thickness in pixels
    const gap = 120; // distance between sleepers
    c.fillStyle = '#6b432b'; // wood base
    for (let x = -gap; x < tileW + gap; x += gap) {
      // wood grain rectangle with small noise
      c.save();
      const jitter = (Math.random()-0.5)*8;
      c.translate(x + jitter, tileH*0.5);
      c.fillRect(0, -sleeperH/2, gap*0.9, sleeperH);
      // add darker streaks
      c.fillStyle = 'rgba(0,0,0,0.08)';
      c.fillRect(4, -sleeperH/2+4, gap*0.5, 4);
      c.fillStyle = '#6b432b';
      c.restore();
    }

    // draw two metallic rails centered
    const railCenterX = tileW/2;
    const railOffset = 120; // pixel offset from center
    function drawRail(cx){
      // base dark strip
      c.fillStyle = '#2a2a2a';
      c.fillRect(cx-6, tileH*0.2, 12, tileH*0.6);
      // highlight
      const grad = c.createLinearGradient(cx-6,0,cx+6,0);
      grad.addColorStop(0, 'rgba(255,255,255,0.10)');
      grad.addColorStop(0.5, 'rgba(255,255,255,0.35)');
      grad.addColorStop(1, 'rgba(255,255,255,0.10)');
      c.fillStyle = grad;
      c.fillRect(cx-2, tileH*0.25, 4, tileH*0.5);
    }
    drawRail(railCenterX - railOffset);
    drawRail(railCenterX + railOffset);

    // subtle grime overlay
    c.fillStyle = 'rgba(10,10,12,0.05)';
    c.fillRect(0,0,tileW,tileH);

    const tex = new THREE.CanvasTexture(cvs);
    tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
    tex.repeat.set(1, 40);
    tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
    tex.encoding = THREE.sRGBEncoding;
    return tex;
  }

  const trackTex = createTrackCanvasTexture();

  // track plane: a narrow strip representing sleepers+ballast; rails will still have metallic highlights
  const trackMat = new THREE.MeshStandardMaterial({ map: trackTex, roughness: 0.85, metalness: 0.05 });
  const trackWidth = 3.0;
  const trackLen = 1000;
  const trackGeo = new THREE.PlaneGeometry(trackWidth, trackLen, 1, 1);
  const track = new THREE.Mesh(trackGeo, trackMat);
  track.rotation.x = -Math.PI/2;
  track.position.y = 0.01;
  track.position.z = 200;
  track.receiveShadow = true;
  scene.add(track);

  // rails (thin metallic extrusions) on top of the track plane for specular highlights and correct shading
  const railMat = new THREE.MeshStandardMaterial({ color:0xaaaeb0, metalness:0.95, roughness:0.28 });
  const railH = 0.14, railW = 0.065, railLen = 1000;
  const railGeo = new THREE.BoxGeometry(railW, railH, railLen);
  const railL = new THREE.Mesh(railGeo, railMat);
  const railR = new THREE.Mesh(railGeo, railMat);
  railL.position.set(-0.535, railH/2 + 0.01, 200);
  railR.position.set( 0.535, railH/2 + 0.01, 200);
  railL.castShadow = true; railL.receiveShadow = false;
  railR.castShadow = true; railR.receiveShadow = false;
  scene.add(railL, railR);

//   // --- ì¹¨ëª©(InstancedMesh) ---
//   const sleeperMat = new THREE.MeshStandardMaterial({
//     map: loadTex(TX.sleeper, {aniso:true, repeat:{x:1, y:1}}),
//     roughness: 0.9, metalness: 0.0
//   });
//   const sleeperGeo = new THREE.BoxGeometry(2.0, 0.08, 0.22); // ê¸¸ì´xë†’ì´xë‘ê»˜(ê°€ì‹œì )
//   const sleeperCount = 2000; // 0.5~0.6m ê°„ê²©ìœ¼ë¡œ 400m
//   const sleepers = new THREE.InstancedMesh(sleeperGeo, sleeperMat, sleeperCount);
//   sleepers.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
//   scene.add(sleepers);
//   const pitch = 0.65;
//   for (let i=0;i<sleeperCount;i++){
//   const z = 200 - i*pitch; // z âˆˆ [200, 200-1000]
//   if (z < -300) break; // -300mê¹Œì§€ë§Œ ë°°ì¹˜í•˜ë©´ ì¶©ë¶„
//   const m = new THREE.Matrix4().makeTranslation(0, 0.02, z);
//   sleepers.setMatrixAt(i, m);
// }

  // --- í”Œë«í¼ (ì •ì°¨ë²½ ê¸°ì¤€ -platformLen ~ 0m, ì˜¤ë¥¸ìª½ì— ë°°ì¹˜) ---
  const platformLen = 210; // m í”Œë«í¼ ê¸¸ì´
  const platH = 1.13; // í”Œë«í¼ ë†’ì´
  const platW = 3.0; // í­
  const platZ = 0 + 200; // ì„¸ê³„ì¢Œí‘œ ë³´ì •(ground/railê³¼ ì¼ì¹˜)
  const platMatTop = new THREE.MeshStandardMaterial({ color: 0xd8dbe1, roughness:0.95, metalness:0.0 });
  const platMatEdge= new THREE.MeshStandardMaterial({ color: 0xf0d060, roughness:0.6, metalness:0.0 }); // ë…¸ë€ ë¼ì¸

  const plat = new THREE.Mesh(new THREE.BoxGeometry(platW, 0.2, platformLen), platMatTop);
  plat.position.set(+2.4, platH, platZ - platformLen/2);
  plat.receiveShadow = true; plat.castShadow = false;
  scene.add(plat);

  const platLine = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.01, platformLen), platMatEdge);
  platLine.position.set(+1.55, platH + 0.105, platZ - platformLen/2);
  platLine.receiveShadow = true; platLine.castShadow = false; scene.add(platLine);

  const platR = new THREE.Mesh(new THREE.BoxGeometry(platW, 0.2, platformLen), platMatTop);
  platR.position.set(-2.4, platH,platZ - platformLen/2);
  platR.receiveShadow = true; platR.castShadow = false; scene.add(platR);

  const platLineR = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.01, platformLen), platMatEdge);
  platLineR.position.set(-1.55, platH + 0.105, platZ - platformLen/2);
  platLineR.receiveShadow = true; platLineR.castShadow = false; scene.add(platLineR);

  // --- í”Œë«í¼ ê¸°ë‘¥ ë° ì§€ë¶• ì¶”ê°€ (ê°„ë‹¨í•œ êµ¬ì¡°ë¡œ ë¶„ìœ„ê¸° í–¥ìƒ) ---
  (function addPlatformRoof(){
    const pillarMat = new THREE.MeshStandardMaterial({ color: 0xdddddd, metalness:0.2, roughness:0.6 });
    const roofMat = new THREE.MeshStandardMaterial({ color: 0xf1f3f6, metalness:0.05, roughness:0.8 });
    const pillarGeo = new THREE.BoxGeometry(0.3, 5, 0.3);
    const roofGeo = new THREE.BoxGeometry(platW*2.5, 0.12, platformLen + 4);

    const startZ = platZ - 2;
    const endZ = platZ - platformLen + 2;
    const spacing = 20.0; // m ì‚¬ì´ ê°„ê²©
    for (let z = startZ; z > endZ; z -= spacing){
      // ì™¼ìª½ ê¸°ë‘¥
      const pL = new THREE.Mesh(pillarGeo, pillarMat);
      pL.position.set(2.7, 2.5, z);
      pL.castShadow = true; pL.receiveShadow = false;
      scene.add(pL);
      // ì˜¤ë¥¸ìª½ ê¸°ë‘¥
      const pR = new THREE.Mesh(pillarGeo, pillarMat);
      pR.position.set(-2.7, 2.5, z);
      pR.castShadow = true; pR.receiveShadow = false;
      scene.add(pR);
    }

    // long roof spanning the platform
    const roof = new THREE.Mesh(roofGeo, roofMat);
    roof.position.set(0, platH + 3.5, platZ - platformLen/2);
    roof.castShadow = true; roof.receiveShadow = true;
    scene.add(roof);
  })();

  // === Red signs on platform every 50m up to 200m ===
const signDistances = [0, 10, 50, 100, 150, 200];

// ê¸°ë‘¥(í´)ê³¼ ë³´ë“œ(íŒë„¬) ì¬ì§ˆ/í˜•ìƒ
const poleMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6, metalness: 0.2 });

const poleGeo = new THREE.BoxGeometry(0.06, 1.2, 0.06); // w,h,d

// Helper: create a circular sign texture with large distance text (e.g., "150m")
function createDistanceSignTexture(distanceMeters){
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const size = 512; // base size
  const width = size * dpr;
  const height = size * dpr;
  const canvas = document.createElement('canvas');
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext('2d');

  // clear
  ctx.clearRect(0, 0, width, height);

  // circle background (red)
  ctx.fillStyle = '#aa0000';
  ctx.beginPath();
  ctx.arc(width/2, height/2, Math.min(width, height) * 0.45, 0, Math.PI * 2);
  ctx.closePath();
  ctx.fill();

  // stroke edge
  ctx.lineWidth = Math.max(2, Math.floor(4 * dpr));
  ctx.strokeStyle = '#550000';
  ctx.stroke();

  // text (white, large)
  const text = `${distanceMeters}`;
  // choose font size to occupy most of the circle
  const fontSize = Math.floor(Math.min(width, height) * 0.28);
  ctx.font = `bold ${fontSize}px sans-serif`;
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  // slight black shadow for contrast
  ctx.shadowColor = 'rgba(0,0,0,0.45)';
  ctx.shadowBlur = Math.max(4, Math.floor(6 * dpr));
  ctx.fillText(text, width/2, height/2 + Math.floor(fontSize*0.03));

  const tex = new THREE.CanvasTexture(canvas);
  tex.encoding = THREE.sRGBEncoding;
  tex.needsUpdate = true;
  tex.minFilter = THREE.LinearFilter;
  tex.magFilter = THREE.LinearFilter;
  return tex;
}

// Collect sign meshes so we can make them face the camera (billboard)
const platformSignMeshes = [];
const platformSignRings = [];

signDistances.forEach(d => {
  const z = 200 - d; // ì •ì°¨ë²½(0m)ì´ z=200 â†’ -dë§Œí¼ ë’¤
  if (z < -300) return; // ì•ˆì „ ì°¨ë‹¨

  // í´(ê¸°ë‘¥)
  const pole = new THREE.Mesh(poleGeo, poleMat);
  pole.position.set(+2.1, platH + 0.1, z); // í”Œë«í¼ ìœ„ì—ì„œ 0.6m ì˜¬ë¼ì˜¨ ê¸°ë‘¥ ì¤‘ì‹¬
  scene.add(pole);

  // ì›í˜• í‘œì§€íŒ: ìº”ë²„ìŠ¤ë¡œ í…ìŠ¤íŠ¸ë¥¼ ê·¸ë ¤ í…ìŠ¤ì²˜ë¡œ ì‚¬ìš©
  const tex = createDistanceSignTexture(d);
  const signMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
  const signRadius = 0.55; // ë¯¸í„° ë‹¨ìœ„ ë°˜ì§€ë¦„ â€” í™”ë©´ì—ì„œ í¼ì§í•˜ê²Œ ë³´ì´ë„ë¡
  const signGeo = new THREE.CircleGeometry(signRadius, 64);
  const sign = new THREE.Mesh(signGeo, signMat);
  // do not fix rotation here â€” we'll billboard it to the camera in the render loop
  sign.position.set(+2.1, platH + 1.25, z);
  scene.add(sign);

  // ì–‡ì€ í…Œë‘ë¦¬ ë§ì„ ì¶”ê°€í•´ ì‹œê°ì  ê°•ì¡°
  const ringGeo = new THREE.RingGeometry(signRadius * 0.88, signRadius * 0.99, 64);
  const ringMat = new THREE.MeshBasicMaterial({ color: 0x770000 });
  const ring = new THREE.Mesh(ringGeo, ringMat);
  ring.position.copy(sign.position);
  scene.add(ring);

  // keep references for billboard updates
  platformSignMeshes.push(sign);
  platformSignRings.push(ring);
});

  // --- ì •ì°¨ë²½(0m, ë°˜íˆ¬ëª… ì´ˆë¡) ---
  const wallMat = new THREE.MeshBasicMaterial({ color: 0xaa0000, transparent:true, opacity:0.28 });
  const wall = new THREE.Mesh(new THREE.PlaneGeometry(2.4, 3), wallMat);
  wall.position.set(0, 2.0, 200); // z=200ì´ â€˜ì •ì°¨ 0mâ€™
  scene.add(wall);
  const wallEdge = new THREE.Mesh(new THREE.PlaneGeometry(2.4, 3), new THREE.MeshBasicMaterial({ color:0xff0000, wireframe:true, transparent:true, opacity:0.65 }));
  wallEdge.position.copy(wall.position);
  scene.add(wallEdge);

  // --- ë‚¨ì€ê±°ë¦¬â†’ì¹´ë©”ë¼/ì˜¤ë¸Œì íŠ¸ ë™ê¸° ---
  // ë””ìì¸: ì¹´ë©”ë¼ z_world = 200 - remaining_m
  // í”Œë«í¼/ë ˆì¼/ìê°ˆì€ ì„¸ê³„ ê³ ì •. ì¹´ë©”ë¼ë§Œ ì´ë™ -> 1ì¸ì¹­ ì£¼í–‰.
  function syncCameraFromState(){
    const rem = Number(window.st?.remaining_m ?? 0);
    const y = 2.8; // ëˆˆë†’ì´ ê¸°ê´€ì‚¬ ëˆˆë†’ì´
    const z = 200 - rem;
    camera.position.set(0, y, z);
    camera.lookAt(0, y + 0.1, z + 4.0); // ì‚´ì§ 
  }

  // --- ë£¨í”„ ---
  let lastRAF = 0;
  function tick(t){
    if (modeSel?.value === 'on'){
  // ì§„í–‰ê°: ìê°ˆ/íŠ¸ë™ í…ìŠ¤ì²˜ ìŠ¤í¬ë¡¤(ë§¤ í”„ë ˆì„ ë°˜ë³µìˆ˜ ë³€ê²½)
  const rem = Number(window.st?.remaining_m ?? 0);
  try{ ballastDiff.offset.y = (rem * 10) % 1; }catch(e){}
  try{ ballastNorm.offset.y = (rem * 10) % 1; }catch(e){}
  try{ if(typeof trackTex !== 'undefined') trackTex.offset.y = (rem * 0.02) % 1; }catch(e){}
      syncCameraFromState();
      // Make platform signs face the camera (billboard) so driver sees them
      try{
        if (Array.isArray(platformSignMeshes) && platformSignMeshes.length){
          for (let i=0;i<platformSignMeshes.length;i++){
            const m = platformSignMeshes[i];
            if (m && m.lookAt) m.lookAt(camera.position);
          }
        }
        if (Array.isArray(platformSignRings) && platformSignRings.length){
          for (let i=0;i<platformSignRings.length;i++){
            const r = platformSignRings[i];
            if (r && r.lookAt) r.lookAt(camera.position);
          }
        }
      }catch(e){ /* non-fatal */ }

      renderer.render(scene, camera);
    }
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);
})();

// Optional station melody audio 
let stationMelody = null;
try {
  stationMelody = new Audio('/static/tokyo_st_announcement.mp3');
  stationMelody.preload = 'auto';
  stationMelody.volume = 0.75;
} catch (e) {
  stationMelody = null;
}

function playStationMelody() {
  if (!stationMelody) return;
  try {
    // í•­ìƒ ì™„ì „ ì´ˆê¸°í™”
    stationMelody.pause();
    stationMelody.currentTime = 0;

    // ë°˜ë³µ ë°©ì§€: autoplay ì†ì„±ì´ë‚˜ loop ë„ê¸°
    stationMelody.loop = false;

    // ê¸°ì¡´ í•¸ë“¤ëŸ¬ ì œê±°
    if (stationMelody._endedHandler) {
      try {
        stationMelody.removeEventListener('ended', stationMelody._endedHandler);
      } catch (e) {}
      stationMelody._endedHandler = null;
    }

    // ì•ˆì „í•˜ê²Œ í•œ ë²ˆë§Œ ì¬ìƒ
    stationMelody.play().catch(err => {
      console.debug('stationMelody play failed:', err);
    });
  } catch (e) {
    console.debug('playStationMelody error', e);
  }
}


const weatherSelect=document.getElementById("weatherSelect"),
      snowflakes=document.querySelector(".snowflakes"),
      raindrops=document.querySelector(".raindrops");

function resize(){ canvas.width=canvas.clientWidth*devicePixelRatio; canvas.height=canvas.clientHeight*devicePixelRatio; } 
addEventListener("resize",resize); resize();

function getEbIdx(){
  const acc = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const n   = acc ? acc.length : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);
  return Math.max(1, n - 1); // 0:N, 1..EB-1:B..., EB:ë§ˆì§€ë§‰
}
function sendCmd(name, delta){
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({type:"cmd", payload:{name, delta}}));
  }
}

/* ===== í¸ì„± & íƒ‘ìŠ¹ë¥  ===== */
function updateTrainLength(){
  const L = document.getElementById("trainLength").value;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTrainLength", length: L } }));
  }
  sendLoadRate();
}
function sendLoadRate(){
  const loadRate = parseFloat(document.getElementById("inputLoadRate").value) || 0;
  const trainLength = parseInt(document.getElementById("trainLength").value) || 8;
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({ type: "cmd", payload: { name: "setLoadRate", loadRate, length: trainLength }}));
  }
}

/* ===== ì…ë ¥ ë³´ì • & ì œí•œ ===== */
const inputSpeed=document.getElementById("inputSpeed"),
      inputDist=document.getElementById("inputDist"),
      inputGrade=document.getElementById("inputGrade"),
      inputLoadRate=document.getElementById("inputLoadRate");

const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
function enforceInt(el,min,max){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^\d-]/g,'');}); el.addEventListener('change',()=>{let v=parseInt(el.value,10); if(isNaN(v)){el.value='';return;} el.value=String(clamp(v,min,max));});}
function enforceFloat(el,min,max,d=1){ el.addEventListener('input',()=>{ el.value=el.value.replace(/[^0-9.\-]/g,'');}); el.addEventListener('change',()=>{let v=parseFloat(el.value); if(isNaN(v)){el.value='';return;} v=clamp(v,min,max); el.value=v.toFixed(d);});}

/* âœ… ë²”ìœ„ ê°±ì‹ : ì†ë„ 40~130 / ê±°ë¦¬ 150~900 */
enforceInt(inputSpeed,40,300);
enforceInt(inputDist,150,900);
enforceInt(inputLoadRate,0,120);
enforceFloat(inputGrade,-10,10,1);

/* âœ… ì†ë„ë³„ ìµœì†Œ ê±°ë¦¬ ê·œì¹™ */
function minDistForSpeed(v) {
  if (v >= 130) return 900;
  if (v >= 120) return 900;
  if (v >= 110) return 800;
  if (v >= 100) return 600;
  if (v >= 90)  return 500;
  if (v >= 80)  return 400;
  if (v >= 70)  return 300;
  if (v >= 60)  return 250;
  if (v >= 50)  return 200;
  return 150; // v >= 40
}
function showHint(msg) {
  fb.innerHTML = `<div class="warn">${msg}</div>`;
  setTimeout(() => {
    if (!st || !st.finished) fb.textContent = "Spaceë¡œ ì‹œì‘. W/Së¡œ ë¸Œë ˆì´í¬ ì¡°ì ˆí•˜ì„¸ìš”.";
  }, 1200);
}
function applySpeedDistanceRule() {
  let v = Number(inputSpeed.value || 0);
  v = Math.min(130, Math.max(40, v));
  const requiredMin = minDistForSpeed(v);
  let d = Number(inputDist.value || 0);
  const absoluteMin = 150, absoluteMax = 900;
  const newMin = Math.max(absoluteMin, requiredMin);

  inputDist.min = String(newMin);

  if (isNaN(d) || d < newMin) {
    inputDist.value = String(newMin);
    showHint(`ì†ë„ ${v} km/hì—ì„œëŠ” ìµœì†Œ ê±°ë¦¬ ${newMin} m ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.`);
  } else if (d > absoluteMax) {
    inputDist.value = String(absoluteMax);
  }
}
inputSpeed.addEventListener('change', applySpeedDistanceRule);
inputSpeed.addEventListener('input',  () => {
  const v = Number(inputSpeed.value || 0);
  const minD = minDistForSpeed(Math.min(130, Math.max(40, v)));
  inputDist.min = Math.max(150, minD);
});
inputLoadRate.addEventListener('change', sendLoadRate);
inputLoadRate.addEventListener('input', () => {
  // ì…ë ¥ ì¤‘ ì¦‰ì‹œ ë°˜ì˜ì„ ì›í•˜ë©´ ìœ ì§€, ë„ˆë¬´ ì‹œë„ëŸ¬ìš°ë©´ ì´ ì¤„ì€ ë¹¼ì„¸ìš”.
  sendLoadRate();
});
/* ===== ë‚ ì”¨ UI ===== */
function muFromWeather(w){return w==="ë¹„ì˜´"?0.6:(w==="ëˆˆì˜´"?0.3:1.0)}
function updateWeatherUI(){
  const w=weatherSelect.value, ov=document.getElementById("overlay");
  if(w==="ëˆˆì˜´"){snowflakes.style.display="block";raindrops.style.display="none";document.documentElement.style.background="#fff";document.body.style.background="#fff";ov.style.background="rgba(255,255,255,.15)";canvas.style.background="#fff";}
  else if(w==="ë¹„ì˜´"){snowflakes.style.display="none";raindrops.style.display="block";document.documentElement.style.background="#4b5d67";document.body.style.background="#4b5d67";ov.style.background="rgba(40,60,80,.35)";canvas.style.background="#4b5d67";}
  else{snowflakes.style.display="none";raindrops.style.display="none";const g="radial-gradient(circle at 50% 20%, #0b0f14, #05070a)";document.documentElement.style.background=g;document.body.style.background=g;ov.style.background="rgba(0,0,0,.6)";canvas.style.background="linear-gradient(#0b0f14,#0a1019)";}
}
weatherSelect.addEventListener("change",()=>{updateWeatherUI();const mu=muFromWeather(weatherSelect.value); if(ws.readyState===WebSocket.OPEN){ws.send(JSON.stringify({type:"cmd",payload:{name:"setMu",value:mu}}));}});
updateWeatherUI();

/* ===== ì‹œì‘/ì¬ì‹œì‘ ===== */
function startRun(){
  inputSpeed.dispatchEvent(new Event('change'));
  inputDist.dispatchEvent(new Event('change'));
  inputGrade.dispatchEvent(new Event('change'));

  applySpeedDistanceRule();

  const speed=Number(inputSpeed.value),
        dist=Number(inputDist.value),
        grade=Number(inputGrade.value),
        mu=muFromWeather(weatherSelect.value);

  if(ws.readyState===WebSocket.OPEN){
const enabled = document.getElementById("tascToggle").checked;
    ws.send(JSON.stringify({ type:"cmd", payload:{ name:"toggleTimer", enabled:true }}));
    ws.send(JSON.stringify({type:"cmd",payload:{name:"setInitial",speed,dist,grade,mu}}));
    ws.send(JSON.stringify({type:"cmd",payload:{name:"start"}}));
  }
  overlay.classList.add("hide"); isFinished=false; overlayShowingResult=false;
  btnMobileRestart.classList.add("hide");
  // play station melody on start (if available)
  try{ playStationMelody(2); }catch(e){}
}
btnStart.addEventListener("click", startRun);

/* ì¬ì‹œì‘ FAB */
const btnMobileRestart=document.getElementById("btnMobileRestart");
btnMobileRestart.addEventListener("click", ()=>{
  if(!overlay.classList.contains("hide")) overlay.classList.add("hide");
  overlay.classList.remove("hide");
  overlayShowingResult=true;
  btnMobileRestart.classList.add("hide");
});

/* ===== ëª¨ë°”ì¼ í„°ì¹˜ ì¡°ì‘ ===== */
if(/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)){
  const game=document.getElementById("hud");
  game.addEventListener("touchstart",(e)=>{
  e.preventDefault();
    if(!overlay.classList.contains("hide")) return;
    if(e.touches.length!==1) return;
    // forceManualOverride();
    const r=game.getBoundingClientRect(), y=e.touches[0].clientY-r.top, half=r.height/2;
    if(y<half){ hapticForNotch(+1); sendCmd("applyNotch",+1); }
    else      { hapticForNotch(-1); sendCmd("applyNotch",-1); }
  }, { passive: false });
}

/* ===== í‚¤ë³´ë“œ ===== */
addEventListener("keydown", (e) => {
  if([" ","w","W","s","S","n","N","e","E","d","D", "a", "A", 'q', 'Q'].includes(e.key)) e.preventDefault();
  if(e.repeat) return;

  if(e.key === " "){ 
    if(ws.readyState !== WebSocket.OPEN) return; 
    startRun(); 
  }
  else if(e.key === "w" || e.key === "W"){ 
    sendCmd("applyNotch", +1); 
  }
  else if(e.key === "s" || e.key === "S"){ 
    sendCmd("applyNotch", -1); 
  }
  else if(e.key === "n" || e.key === "N"){ 
    sendCmd("release", 0); 
  }
  else if(e.key === "e" || e.key === "E"){ 
    sendCmd("emergencyBrake", 0);  
  }
  else if(e.key === "d" || e.key === "D"){ 
    // ì œë™ 1ë‹¨
    sendCmd("setNotch", 1);  
  }
  else if(e.key === "a" || e.key === "A"){
    if(vehicle && vehicle.notches){
      sendCmd("setNotch", vehicle.notches - 4); // EB ì§ì „ notch
    }
  }
  else if(e.key === "q" || e.key === "Q"){
    if(vehicle && vehicle.forward_notches){
      sendCmd("setNotch", -vehicle.forward_notches); // EB ì§ì „ notch
    }
  }

});

/* ===== HUD & ìƒíƒœ ===== */
const grade_percentEl=document.getElementById("grade_percent");
let isFinished=false, overlayShowingResult=false, st=null, lastTimestamp=0, prevMaxDistance=0;
function loop(ts){ if(!lastTimestamp) lastTimestamp=ts; lastTimestamp=ts; if(st) drawHUD(st); requestAnimationFrame(loop); }
requestAnimationFrame(loop);

function formatTimeSec(secInt) {
  const sign = secInt < 0 ? "+" : "";
  const s = Math.abs(secInt);
  const m = Math.floor(s / 60);
  const s2 = s % 60;
  return `${sign}<span class="min">${m < 10 ? "0" : ""}${m}</span><span class="sep">:</span><span class="sec">${s2 < 10 ? "0" : ""}${s2}</span>`;
}


// ===== WebSocket (ë‹¨ì¼ í•¸ë“¤ëŸ¬ë¡œ êµì²´) =====
ws.onmessage = (ev) => {
  const msg = JSON.parse(ev.data);
  if (msg.type !== "state") return;

  // ìƒíƒœ ì €ì¥
  st = msg.payload;
  window.st = st;

  // ìˆ«ì HUD ê°±ì‹ 
  const remRaw = st.remaining_m;
  const rem = (typeof remRaw === "number") ? remRaw : parseFloat(remRaw);
  // ê±°ë¦¬ í‘œì‹œ
if (rem >= 0) {
  if (rem <= 2)  remEl.textContent = Math.round(rem * 100) + " cm";
  else           remEl.textContent = rem.toFixed(0) + " m";
} else {
  if (rem >= -2) remEl.textContent = "-" + Math.round(Math.abs(rem) * 100) + " cm";
  else           remEl.textContent = "-" + Math.abs(rem).toFixed(0) + " m";
}

// âœ… ìƒ‰ìƒ ì¡°ê±´ ì ìš© (Â±0.35m ì´ë‚´ë©´ ì´ˆë¡ìƒ‰, ì•„ë‹ˆë©´ ê¸°ë³¸)
if (Math.abs(rem) <= 0.35) {
  remEl.style.color = "#9effb5";   // ì´ˆë¡
} else {
  remEl.style.color = "";          // ê¸°ë³¸ (.statì˜ í•˜ì–€ìƒ‰ìœ¼ë¡œ ë³µê·€)
}

  spdEl.textContent = (st.v * 3.6).toFixed(1);


const maxIdx = (vehicle?.notches ?? 10) - 1; // EB ì¸ë±ìŠ¤
const forwardAccels = vehicle?.forward_notch_accels ?? [0.139, 0.278, 0.417, 0.556, 0.694];

let notchText = "N";
let notchColor = "#9effb5"; // ê¸°ë³¸ ì´ˆë¡

if (st.lever_notch === 0) {
  notchText = "N";
  notchColor = "#9effb5";     // ì´ˆë¡
} else if (st.lever_notch < 0) {
  const idx = -st.lever_notch - 1; // -1 â†’ 0, -2 â†’ 1
  notchText = `P${idx + 1}`;
  notchColor = "#ADD8E6";        // ì£¼í™©
  const accel = forwardAccels[idx] ?? forwardAccels[forwardAccels.length - 1];
  // í•„ìš”í•˜ë©´ accel ë³€ìˆ˜ë¡œ ê°€ì†ë„ ì œì–´ ê°€ëŠ¥
} else if (st.lever_notch === maxIdx) {
  notchText = "EB";
  notchColor = "#ff5757";     // ë¹¨ê°•
} else {
  notchText = `B${st.lever_notch}`;
  notchColor = "#ed9a09";     // ê¸°ì¡´ ì£¼í™©/í™©í† ìƒ‰
}


notchEl.textContent = notchText;
notchEl.style.color = notchColor;




  grade_percentEl.textContent = (10 * st.grade_percent).toFixed(1);



  const running  = !!st.running;
  const finished = !!st.finished;
  const budget   = Number(st.time_budget_s ?? 0);
  const remainI  = Number(st.time_remaining_int ?? 0);
let toShowInt = (running || finished) ? remainI : Math.round(budget);
if (!Number.isFinite(toShowInt)) {
  const remainF = Number(st.time_remaining_s);
  toShowInt = Number.isFinite(remainF) ? Math.floor(remainF) : Math.floor(Number(st.t) || 0);
}

timerEl.innerHTML = formatTimeSec(toShowInt);

// âœ… ìƒ‰ìƒ ì¡°ê±´ ì¶”ê°€
if (Math.abs(toShowInt) <= 2) {
  timerEl.style.color = "#9effb5";   // ì´ˆë¡ìƒ‰
  timerEl.classList.remove('bad');
} else if (toShowInt < 0) {
  timerEl.style.color = "";          // ê¸°ë³¸ ìƒ‰ìƒ (CSS .stat)
  timerEl.classList.add('bad');      // ìŒìˆ˜ë©´ ë¹¨ê°•
} else {
  timerEl.style.color = "";          // ê¸°ë³¸ ìƒ‰ìƒ (CSS .stat)
  timerEl.classList.remove('bad');
} 

  // ê·¸ë˜í”„/ë¯¸ë‹ˆ ì¸ë””ì¼€ì´í„°
  drawHUD(st);
  drawBrakeLadderMini(st);
  

  // âš  í”¼ë“œë°±(fb) UIëŠ” ì—¬ê¸°ì„œ ê±´ë“œë¦¬ì§€ ë§ˆì„¸ìš” (ì–¸ì–´ í† ê¸€ì€ setLangì—ì„œ ì²˜ë¦¬)
const isOverlayOpen = !overlay.classList.contains('hide');

if (st.finished && !isOverlayOpen) {
  // ê²Œì„ì´ ëë‚¬ê³ , ì˜¤ë²„ë ˆì´ê°€ ë‹«í˜€ ìˆì„ ë•Œë§Œ FAB í‘œì‹œ
  if (/Mobi|Android|iPhone|iPad/i.test(navigator.userAgent)) {
    btnMobileRestart.classList.remove('hide');
  } else {
    btnMobileRestart.classList.add('hide');
  }
} else {
  // ê·¸ ì™¸ì—ëŠ” í•­ìƒ ìˆ¨ê¹€ (ì˜¤ë²„ë ˆì´ê°€ ë–  ìˆìœ¼ë©´ ë‹¹ì—°íˆ ìˆ¨ê¹€)
  btnMobileRestart.classList.add('hide');
}
// onmessage ë‚´ë¶€
const serverEnabled = !!st.tasc_enabled;
if (tascToggle.checked !== serverEnabled) {
  tascToggle.checked = serverEnabled; // ì„œë²„ ê¸°ì¤€ìœ¼ë¡œ ê°•ì œ ë™ê¸°í™”
}
};

/* ===== HUD ê·¸ë¦¬ê¸° (ê¸°ì¡´ ìœ ì§€) ===== */
function drawHUD(st){
  const dpr=devicePixelRatio||1, w=canvas.width, h=canvas.height;
  ctx.clearRect(0,0,w,h);
  const v0=st.v, lever=st.lever_notch, currentPos=st.pos??0, stopPos=st.stopPos??500;
  const remaining=(typeof st.remaining_m==="number")?Math.max(0,st.remaining_m):Math.max(0,stopPos-currentPos);
  const maxDecel=Math.max(...Object.values(brakeDecels)); const maxStop=maxDecel>0?(v0*v0)/(2*maxDecel):0;
  const speedFactor=Math.max(.3,Math.min(1,v0/10)); const adjusted=remaining*(1+(1-speedFactor)*.5);
  const s_b1=(brakeDecels[1]??0)>0?(v0*v0)/(2*brakeDecels[1]):0, s_b2=(brakeDecels[2]??0)>0?(v0*v0)/(2*brakeDecels[2]):0;
  const target=Math.max(1,maxStop*1.5,Math.max(1,Math.sqrt(adjusted)*10)*1.2,s_b1*1.1,s_b2*1.1);
  prevMaxDistance = prevMaxDistance===0 ? target : prevMaxDistance*.9 + target*.1;

  const left=48*dpr, right=12*dpr, usableW=w-left-right, X=d=>left+usableW*(d/prevMaxDistance);
  const vmax=Math.max(1,v0*3.6*1.2);
  const bottom=28*dpr, top=12*dpr, usableH=h-bottom-top, Y=v=>h-bottom-usableH*(v/vmax);

  ctx.strokeStyle="#20334d"; ctx.lineWidth=1*dpr; ctx.beginPath(); ctx.moveTo(left,top); ctx.lineTo(left,h-bottom); ctx.lineTo(w-right,h-bottom); ctx.stroke();

  ctx.fillStyle="#888"; ctx.font=`${10*dpr}px sans-serif`; ctx.textAlign="center"; ctx.textBaseline="top";
  for(let d=0; d<=prevMaxDistance; d+=100){ const x=X(d); ctx.beginPath(); ctx.moveTo(x,h-bottom); ctx.lineTo(x,h-bottom+4*dpr); ctx.stroke(); ctx.fillText(`${Math.round(d)}`,x,h-bottom+6*dpr); }
  ctx.textAlign="right"; ctx.textBaseline="middle";
  for(let k=0;k<=vmax;k+=10){ const y=Y(k); ctx.beginPath(); ctx.moveTo(left-4*dpr,y); ctx.lineTo(left,y); ctx.stroke(); ctx.fillText(`${k}`,left-6*dpr,y); }

  ctx.lineWidth=2*dpr; 
  const maxNotch = vehicle?.notches ?? 10;   // ì´ ê°œìˆ˜(0~maxIdx)
  const maxIdx   = maxNotch - 1;  // EB ì¸ë±ìŠ¤
  for(let n=0;n<maxNotch;n++){
    const a=brakeDecels[n]??0; if(a<=0) continue;
    const s=(v0*v0)/(2*a);
    ctx.beginPath(); ctx.strokeStyle = n===lever ? "#ffae00" : "#3fa9ff";
    for(let i=0;i<=100;i++){
      const f=i/100, ds=s*f, v=Math.sqrt(Math.max(0,v0*v0-2*a*ds));
      const x=X(ds), y=Y(v*3.6); if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
    }
    ctx.stroke();
    ctx.fillStyle=n===lever?"#ffae00":"#3fa9ff"; ctx.font=`${12*dpr}px 'Orbitron', sans-serif`;
    const tX=X(s); const label = (n===0) ? "N" : (n===maxIdx ? "EB" : `B${n}`);
    ctx.fillText(label, tX+5*dpr, Y(0)+12*dpr);
  }

  const xRed=X(remaining); ctx.strokeStyle="#f00"; ctx.lineWidth=1.5*dpr; ctx.beginPath(); ctx.moveTo(xRed,Y(0)); ctx.lineTo(xRed,Y(vmax)); ctx.stroke();
  ctx.fillStyle="#f00"; ctx.font=`${14*dpr}px 'Orbitron', sans-serif`; ctx.textAlign="center"; ctx.fillText("ë‚¨ì€ ê±°ë¦¬", xRed, Y(vmax)-18*dpr);

  // const ribbonW=16*dpr, ribbonH=h*.9, ribbonX=w-right-ribbonW-10*dpr+20, ribbonY=((h-ribbonH)/2)-32;
  // ctx.fillStyle="rgba(100,100,100,.1)"; ctx.strokeStyle="rgba(100,100,100,.3)"; ctx.lineWidth=1.5*dpr;
  // ctx.beginPath(); ctx.rect(ribbonX,ribbonY,ribbonW,ribbonH); ctx.fill(); ctx.stroke();

  // const centerY=(ribbonY+ribbonH/2)-14, barH=12*dpr;
  // ctx.fillStyle="rgba(60,60,60,.9)"; ctx.fillRect(ribbonX+2*dpr, centerY-barH/2, ribbonW-4*dpr, barH);

  
// ë‚ ì”¨ê°€ ë§‘ìŒì´ë©´ ë°˜íˆ¬ëª… í°ìƒ‰ í†¤ ì‚¬ìš©
const isClear = (weatherSelect?.value === "ë§‘ìŒ");

  // ë¦¬ë³¸(íšŒìƒ‰ ì‚¬ê°í˜•) í…Œë‘ë¦¬/ì±„ì›€
  const ribbonFill = isClear ? "rgba(255,255,255,0.12)" : "rgba(100,100,100,0.10)";
  const ribbonStroke = isClear ? "rgba(255,255,255,0.35)" : "rgba(100,100,100,0.30)";

  // ê°€ìš´ë° ê°€ë¡œ ë°”(ê¸°ì¤€ ë°”)
  const centerBarFill = isClear ? "rgba(255,255,255,0.50)" : "rgba(60,60,60,0.90)";

  // ë‹¤ì´ì•„ëª¬ë“œ(ì •ì°¨ ìœ„ì¹˜ ë§ˆì»¤)
  const diamondFill = isClear ? "rgba(255,255,255,0.70)" : "#444";
  const diamondStroke = isClear ? "#FFD500" : "#222";


  // PC/ëª¨ë°”ì¼ íŒë³„
  const isMobile = window.innerWidth < 768; 

  // ë³´ì •ê°’ ì„¤ì • (ì›í•˜ëŠ” ê°’ìœ¼ë¡œ ìˆ˜ì • ê°€ëŠ¥)
  // -32 -14
  const offsetRibbonY = isMobile ? -32 : -12; 
  const offsetCenterY = isMobile ? -14 : -5; 

  // ë¦¬ë³¸ ìœ„ì¹˜/í¬ê¸° ê³„ì‚°
  const ribbonW = 16 * dpr, 
        ribbonH = h * .9, 
        ribbonX = w - right - ribbonW - 10 * dpr + 20, 
        ribbonY = ((h - ribbonH) / 2) + offsetRibbonY;

  ctx.fillStyle = "rgba(100,100,100,.1)";
  ctx.strokeStyle = "rgba(100,100,100,.3)";
  ctx.lineWidth = 1.5 * dpr;
  ctx.beginPath();
  ctx.rect(ribbonX, ribbonY, ribbonW, ribbonH);
  ctx.fill();
  ctx.stroke();

  // ì¤‘ì•™ ë°”
  const centerY = (ribbonY + ribbonH / 2) + offsetCenterY, 
        barH = 12 * dpr;

  ctx.fillStyle = diamondFill;
  ctx.fillRect(ribbonX + 2 * dpr, centerY - barH / 2, ribbonW - 4 * dpr, barH);

  const rem=Math.min(Math.max(st.remaining_m??st.L,-st.L), st.L);
  const diamondW=16*dpr, diamondH=10*dpr, dX=ribbonX+ribbonW/2;
  const normalized=(rem-(-5))/(5-(-5));
  const dY=ribbonY+(ribbonH*(1-normalized))-diamondH/2;
  const adjY=Math.min(Math.max(dY, ribbonY-10*dpr), ribbonY+ribbonH-diamondH+10*dpr);

  ctx.fillStyle=diamondFill; ctx.strokeStyle=diamondStroke; 

  ctx.lineWidth=2*dpr; ctx.beginPath();
  ctx.moveTo(dX, adjY-diamondH/2); 
  ctx.lineTo(dX+diamondW/2, adjY); 
  ctx.lineTo(dX, adjY+diamondH/2);
  ctx.lineTo(dX-diamondW/2, adjY);
  ctx.closePath(); 
  ctx.fill(); 
  ctx.stroke();
  // also draw the large right-side ribbon (fixed canvas)
  try{ if(typeof drawRightRibbon === 'function') drawRightRibbon(st); }catch(e){}

/* === TASC ê²½ê³ ë“± (HUD ìœ„) === */
/* === TASC ê²½ê³ ë“± (HUD ìœ„) === */
/* === TASC ê²½ê³ ë“± (HUD ìœ„) === */
{
  const pad = 8 * dpr;       // í…ìŠ¤íŠ¸ì™€ í…Œë‘ë¦¬ ì‚¬ì´ ì—¬ë°±
  const textW = 18 * dpr;    
  const textH = 9 * dpr;     
  const radius = 2 * dpr;    // ëª¨ì„œë¦¬ ë°˜ê²½

  const lightW = textW + pad*2 + 8*dpr; // ê¸°ì¡´ë³´ë‹¤ 6px ë” ëŠ˜ë¦¼
  const lightH = textH + pad*2 - 2*dpr; // ê¸°ì¡´ë³´ë‹¤ 2px ì¤„ì„

  const isMobile = window.innerWidth < 768;
  const lightX = isMobile 
    ? w - lightW - 35 * dpr
    : w - lightW - 30 * dpr;
  const lightY = 15 * dpr;

  const blinkOn = Math.floor(Date.now() / 250) % 2 === 0;

  // Set the fill color based on the state
  let fillColor = "#444"; 
  if (!st.tasc_armed && !st.tasc_enabled) fillColor = "#444";
  else if (st.tasc_active) fillColor = "#fec670";
  else if (st.tasc_armed && !st.tasc_active && blinkOn) fillColor = "#fec670";

  // Draw rounded rectangle for TASC light
  ctx.beginPath();
  ctx.moveTo(lightX + radius, lightY);
  ctx.lineTo(lightX + lightW - radius, lightY);
  ctx.quadraticCurveTo(lightX + lightW, lightY, lightX + lightW, lightY + radius);
  ctx.lineTo(lightX + lightW, lightY + lightH - radius);
  ctx.quadraticCurveTo(lightX + lightW, lightY + lightH, lightX + lightW - radius, lightY + lightH);
  ctx.lineTo(lightX + radius, lightY + lightH);
  ctx.quadraticCurveTo(lightX, lightY + lightH, lightX, lightY + lightH - radius);
  ctx.lineTo(lightX, lightY + radius);
  ctx.quadraticCurveTo(lightX, lightY, lightX + radius, lightY);
  ctx.closePath();

  // Fill the rectangle with the color
  ctx.fillStyle = fillColor;
  ctx.fill();

  // Apply gradient stroke for a 3D effect
  const gradient = ctx.createLinearGradient(lightX, lightY, lightX, lightY + lightH);
  gradient.addColorStop(0, "#999");  // Lighter gray at the top
  gradient.addColorStop(1, "#444");  // Darker gray at the bottom

  // Set stroke style to the gradient
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = gradient;
  ctx.stroke();

  // Set text style and alignment for TASC text
  let tascTextColor = "#fff"; // ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ (í°ìƒ‰)

  // ë¶ˆì´ ë“¤ì–´ì™”ì„ ë•Œ ìë™ ë²„íŠ¼ì²˜ëŸ¼ ê²€ì€ìƒ‰ìœ¼ë¡œ ë°”ê¾¸ê¸°
  if (st.tasc_enabled && st.tasc_active) {
    tascTextColor = "#000";  // ë¶ˆì´ ë“¤ì–´ì˜¤ë©´ í…ìŠ¤íŠ¸ ìƒ‰ìƒ ê²€ì€ìƒ‰
  }

  ctx.fillStyle = tascTextColor; // í…ìŠ¤íŠ¸ ìƒ‰ìƒ ë³€ê²½
  ctx.font = `${7 * dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";

  // Split text by newline and position each line
  const text = "TASC\nìë™";
  const lines = text.split("\n");
  const lineHeight = 10 * dpr; // Adjust this value for spacing between lines

  // Draw each line at the center position
  lines.forEach((line, index) => {
    ctx.fillText(line, lightX + lightW / 2, lightY + lightH / 2 + index * lineHeight);
  });

  /* === ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ (ì´ˆë¡ìƒ‰) === */
  const stopBtnX = lightX - lightW - 3 * dpr;  // ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ì˜ X ìœ„ì¹˜
  const stopBtnY = lightY;  // Y ìœ„ì¹˜ëŠ” TASC ê²½ê³ ë“±ê³¼ ë™ì¼í•˜ê²Œ

  const stopBtnW = textW + pad * 2 + 8 * dpr; // ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ì˜ ë„ˆë¹„
  const stopBtnH = textH + pad * 2 - 2 * dpr; // ì •ìœ„ì¹˜ ì •ì°¨ ë²„íŠ¼ì˜ ë†’ì´

  let stopBtnColor = "#444"; // ê¸°ë³¸ íšŒìƒ‰
  let stopTextColor = "#fff"; // ê¸°ë³¸ í…ìŠ¤íŠ¸ ìƒ‰ìƒ (í°ìƒ‰)

  // Check if the button should be green (ì •ìœ„ì¹˜ ì •ì°¨ ì™„ë£Œ ìƒíƒœ)
  if (st.tasc_enabled && st.v == 0) {
    stopBtnColor = "#9be071";  // ì´ˆë¡ìƒ‰ (ì •ìœ„ì¹˜ ì •ì°¨ ì™„ë£Œ ìƒíƒœ)
    stopTextColor = "#000";  // ì´ˆë¡ìƒ‰ì¼ ë•Œ í…ìŠ¤íŠ¸ ìƒ‰ìƒ ê²€ì€ìƒ‰
  }

  // Draw rounded rectangle for Stop Button
  ctx.beginPath();
  ctx.moveTo(stopBtnX + radius, stopBtnY);
  ctx.lineTo(stopBtnX + stopBtnW - radius, stopBtnY);
  ctx.quadraticCurveTo(stopBtnX + stopBtnW, stopBtnY, stopBtnX + stopBtnW, stopBtnY + radius);
  ctx.lineTo(stopBtnX + stopBtnW, stopBtnY + stopBtnH - radius);
  ctx.quadraticCurveTo(stopBtnX + stopBtnW, stopBtnY + stopBtnH, stopBtnX + stopBtnW - radius, stopBtnY + stopBtnH);
  ctx.lineTo(stopBtnX + radius, stopBtnY + stopBtnH);
  ctx.quadraticCurveTo(stopBtnX, stopBtnY + stopBtnH, stopBtnX, stopBtnY + stopBtnH - radius);
  ctx.lineTo(stopBtnX, stopBtnY + radius);
  ctx.quadraticCurveTo(stopBtnX, stopBtnY, stopBtnX + radius, stopBtnY);
  ctx.closePath();

  // Fill the button with the color
  ctx.fillStyle = stopBtnColor;
  ctx.fill();

  // Apply gradient stroke for a 3D effect
  const stopBtnGradient = ctx.createLinearGradient(stopBtnX, stopBtnY, stopBtnX, stopBtnY + stopBtnH);
  stopBtnGradient.addColorStop(0, "#999");  // Lighter gray at the top
  stopBtnGradient.addColorStop(1, "#444");  // Darker gray at the bottom

  // Set stroke style to the gradient
  ctx.lineWidth = 2 * dpr;
  ctx.strokeStyle = stopBtnGradient;
  ctx.stroke();

  // Set text style and alignment for Stop Button text
  ctx.fillStyle = stopTextColor;  // í…ìŠ¤íŠ¸ ìƒ‰ìƒì€ ì •ìœ„ì¹˜ ìƒíƒœì— ë”°ë¼ ê²°ì •
  ctx.font = `${7 * dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";

  // Draw text for the Stop Button
  const stopText = "TASC\nì •ìœ„ì¹˜";
  const stopLines = stopText.split("\n");
  const stopLineHeight = 10 * dpr;  // Adjust this value for spacing between lines

  // Draw each line of text at the center position
  stopLines.forEach((line, index) => {
    ctx.fillText(line, stopBtnX + stopBtnW / 2, stopBtnY + stopBtnH / 2 + index * stopLineHeight);
  });


/* === í¸ì„±ìˆ˜ í‘œì‹œ (ì •ìœ„ì¹˜ ë²„íŠ¼ ì™¼ìª½) === */
{
  const trainLength = parseInt(document.getElementById("trainLength").value) || 10; 
  const pad = 6 * dpr;
  const boxW = 32 * dpr;
  const boxH = 24.5 * dpr;
  const radius = 4 * dpr;

  // ì •ìœ„ì¹˜ ë²„íŠ¼ ìœ„ì¹˜ ì°¸ê³ 
  const boxX = stopBtnX - boxW - 4*dpr; // ì •ìœ„ì¹˜ ë²„íŠ¼ ì™¼ìª½ì— 4px ê°„ê²©
  const boxY = stopBtnY - 0.5*dpr;                // Y ìœ„ì¹˜ ë§ì¶¤

  // ë°•ìŠ¤ ê·¸ë¦¬ê¸°
  ctx.fillStyle = "#ff5757";
  ctx.beginPath();
  ctx.moveTo(boxX + radius, boxY);
  ctx.lineTo(boxX + boxW - radius, boxY);
  ctx.quadraticCurveTo(boxX + boxW, boxY, boxX + boxW, boxY + radius);
  ctx.lineTo(boxX + boxW, boxY + boxH - radius);
  ctx.quadraticCurveTo(boxX + boxW, boxY + boxH, boxX + boxW - radius, boxY + boxH);
  ctx.lineTo(boxX + radius, boxY + boxH);
  ctx.quadraticCurveTo(boxX, boxY + boxH, boxX, boxY + boxH - radius);
  ctx.lineTo(boxX, boxY + radius);
  ctx.quadraticCurveTo(boxX, boxY, boxX + radius, boxY);
  ctx.closePath();
  ctx.fill();

  // ìˆ«ì í‘œì‹œ
  ctx.fillStyle = "#000"; // ìˆ«ì ìƒ‰ìƒ
  ctx.font = `${12*dpr}px 'A-OTF Shin Go Pro', sans-serif`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText(trainLength, boxX + boxW/2, boxY + boxH/2);
}




  
}



}


/* ===== ë¸Œë ˆì´í¬ ë¯¸ë‹ˆ ì¸ë””ì¼€ì´í„° ===== */
const ladderCanvas = document.getElementById('brakeLadder');
function sizeLadderCanvas() {
  if (!ladderCanvas) return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = ladderCanvas.clientWidth;
  const cssH = ladderCanvas.clientHeight;
  ladderCanvas.width  = Math.max(1, Math.round(cssW * dpr));
  ladderCanvas.height = Math.max(1, Math.round(cssH * dpr));
}
addEventListener('resize', sizeLadderCanvas);
sizeLadderCanvas();

function drawBrakeLadderMini(st) {
  const ctx2 = ladderCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const w = ladderCanvas.width, h = ladderCanvas.height;
  if (!w || !h) return;
  ctx2.clearRect(0, 0, w, h);

  const accArr  = (vehicle && Array.isArray(vehicle.notch_accels)) ? vehicle.notch_accels : null;
  const notches = accArr ? accArr.length : (vehicle && Number.isInteger(vehicle.notches) ? vehicle.notches : 10);
  const ebIdx   = accArr ? Math.max(1, accArr.length - 1) : Math.max(1, notches - 1);
  const blocks  = ebIdx;
  const cur     = Math.max(0, Math.min(ebIdx, st.lever_notch|0));

  ctx2.fillStyle = "rgba(100,100,100,0.10)";
  ctx2.fillRect(0, 0, w, h);

  const pad  = 2 * dpr;
  const gap  = Math.max(2 * dpr, Math.round(h * 0.02));
  const bH   = (h - pad*2 - gap*(blocks-1)) / blocks;
  const bW   = w - pad*2;
  const x    = pad;

  for (let k = 1; k <= ebIdx - 1; k++) {
    const i = k - 1;
    const y = h - pad - (i + 1) * bH - i * gap;
    ctx2.fillStyle = "rgba(60,80,100,0.35)";
    ctx2.fillRect(x, y, bW, bH);
    if (cur !== ebIdx && k <= cur) { ctx2.fillStyle = "#ffd34d"; ctx2.fillRect(x, y, bW, bH); }
    ctx2.strokeStyle = "rgba(20,30,45,0.6)";
    ctx2.lineWidth   = 1 * dpr;
    ctx2.strokeRect(x, y, bW, bH);
  }

  const yEB = h - pad - (ebIdx) * bH - (ebIdx - 1) * gap;
  ctx2.fillStyle = "rgba(60,80,100,0.35)";
  ctx2.fillRect(x, yEB, bW, bH);
  if (cur === ebIdx) { ctx2.fillStyle = "#ff5757"; ctx2.fillRect(x, yEB, bW, bH); }
  ctx2.strokeStyle = "rgba(20,30,45,0.6)";
  ctx2.lineWidth   = 1 * dpr;
  ctx2.strokeRect(x, yEB, bW, bH);

  
}

/* ===== í° ìš°ì¸¡ ë¦¬ë³¸ ìº”ë²„ìŠ¤ (ê³ ì •) ===== */
const ribbonBigCanvas = document.getElementById('ribbonBig');
function sizeRibbonBigCanvas() {
  if (!ribbonBigCanvas) return;
  const dpr = window.devicePixelRatio || 1;
  const cssW = ribbonBigCanvas.clientWidth || 72;
  const cssH = ribbonBigCanvas.clientHeight || (window.innerHeight * 0.8);
  ribbonBigCanvas.width = Math.max(1, Math.round(cssW * dpr));
  ribbonBigCanvas.height = Math.max(1, Math.round(cssH * dpr));
}
addEventListener('resize', sizeRibbonBigCanvas);
sizeRibbonBigCanvas();

function drawRightRibbon(st){
  if (!ribbonBigCanvas) return;
  if (!st) return;
  const ctxR = ribbonBigCanvas.getContext('2d');
  const dpr = window.devicePixelRatio || 1;
  const w = ribbonBigCanvas.width, h = ribbonBigCanvas.height;
  ctxR.clearRect(0,0,w,h);

  // ìƒ‰ìƒ/ëª¨ë“œ ì¬ì‚¬ìš© (ì¼ê´€ëœ ìŠ¤íƒ€ì¼)
  const isClear = (weatherSelect?.value === "ë§‘ìŒ");
  const ribbonFill = isClear ? "rgba(255,255,255,0.01)" : "rgba(100,100,100,0.10)";
  const ribbonStroke = isClear ? "rgba(255,255,255,0.35)" : "rgba(100,100,100,0.30)";
  const centerBarFill = "rgba(16, 250, 13, 0.90)"; // ì—°í•œ ì´ˆë¡ìƒ‰
  const diamondFill= "rgba(255,241,0,0.90)";
  const diamondStroke= "#FD0800";

  // ëª¨ë°”ì¼/ë°ìŠ¤í¬í†± ë³´ì • (ì›ë˜ì™€ ë¹„ìŠ·í•œ ë¹„ìœ¨ ìœ ì§€)
  const isMobileLocal = window.innerWidth < 768;
  // Do not draw on mobile (CSS also hides the canvas) to save CPU
  if (isMobileLocal) { ctxR.clearRect(0,0,w,h); return; }
  const offsetRibbonY = isMobileLocal ? -32 : -12;
  const offsetCenterY = isMobileLocal ? -14 : -7.5;

  // ë” í¬ê²Œ ë³´ì´ê²Œ ìŠ¤ì¼€ì¼ì„ í‚¤ì›€
  const scale = 3; // ì›í•˜ëŠ” ë§Œí¼ í‚¤ìš°ì„¸ìš” (2~4 ê¶Œì¥)
  const ribbonW = Math.min(72 * dpr, 24 * dpr * scale);
  const ribbonH = h * 0.95;
  const ribbonX = (w - ribbonW) / 2;
  const ribbonY = ((h - ribbonH) / 2) + offsetRibbonY * dpr;

  // ë°°ê²½ ë°•ìŠ¤
  ctxR.fillStyle = ribbonFill;
  ctxR.strokeStyle = ribbonStroke;
  ctxR.lineWidth = 1.5 * dpr;
  ctxR.beginPath();
  ctxR.rect(ribbonX, ribbonY, ribbonW, ribbonH);
  ctxR.fill();
  ctxR.stroke();

  // ì¤‘ì•™ ë°”
  const centerY = (ribbonY + ribbonH / 2) + offsetCenterY * dpr;
  // Make the center bar larger: increase height and reduce horizontal padding so it appears wider
  const barHeightBase = 60; // px base at DPR=1 (tweak this to change size)
  const barH = barHeightBase * dpr * scale; // taller than default
  const horizontalPadding = 1 * dpr; // smaller padding -> wider bar
  ctxR.fillStyle = centerBarFill;
  ctxR.fillRect(ribbonX + horizontalPadding, centerY - barH / 2, ribbonW - horizontalPadding * 2, barH);

  // ë‚´ë¶€ì— ì‘ì€ ë°˜íˆ¬ëª… í°ìƒ‰ ë°•ìŠ¤ ì¶”ê°€ (ë„ˆë¹„ ë™ì¼, ë†’ì´ë§Œ ì‘ìŒ)
  (function(){
    const innerWidth = Math.max(4 * dpr, ribbonW - horizontalPadding * 2); // same width as bar
    const innerHeight = barH * 0.15; // smaller height
    const innerX = ribbonX + horizontalPadding;
    const innerY = centerY - innerHeight / 2;
    ctxR.fillStyle = 'rgba(204, 253, 208, 0.8)';
    ctxR.fillRect(innerX, innerY, innerWidth, innerHeight);
  })();

  // ë‹¤ì´ì•„ëª¬ë“œ ìœ„ì¹˜
  const rem = Math.min(Math.max(st.remaining_m ?? st.L, -st.L), st.L);
  const diamondW = 8 * dpr * scale, diamondH = 5 * dpr * scale, dX = ribbonX + ribbonW / 2;
  const normalized = (rem - (-5)) / (5 - (-5));
  const dY = ribbonY + (ribbonH * (1 - normalized)) - diamondH / 2;
  const adjY = Math.min(Math.max(dY, ribbonY - 10 * dpr), ribbonY + ribbonH - diamondH + 10 * dpr);

  ctxR.fillStyle = diamondFill; ctxR.strokeStyle = diamondStroke;
  ctxR.lineWidth = 2 * dpr;
  ctxR.beginPath();
  ctxR.moveTo(dX, adjY - diamondH / 2);
  ctxR.lineTo(dX + diamondW / 2, adjY);
  ctxR.lineTo(dX, adjY + diamondH / 2);
  ctxR.lineTo(dX - diamondW / 2, adjY);
  ctxR.closePath();
  ctxR.fill();
  ctxR.stroke();
}

/* ===== ì „ë™ì°¨/ì‹œë¦¬ì¦ˆ/í¸ì„± ===== */
const TRAIN_DB={
  E233:[
    {code:"JR EAST E233-1000", lines:"ê²Œì´íŒí† í˜¸ì¿ ì„ Â·ë„¤ê¸°ì‹œì„ ", file:"/static/e233_1000.json", lengths:[10]},
    {code:"JR EAST E233-2000", lines:"ì¡°ë°˜ ì™„í–‰ì„ , ì¹˜ìš”ë‹¤ì„ , ì˜¤ë‹¤ì™€ë¼ì„ , íƒ€ë§ˆì„ ", file:"/static/e233_2000.json", lengths:[10]},
    {code:"JR EAST E233-3000", lines:"ìš°ì—ë…¸ë„ì¿„ë¼ì¸, ì‡¼ë‚œì‹ ì£¼ì¿ ë¼ì¸", file:"/static/e233_3000.json", lengths:[5,10,15]}
  ],
  E235:[
    {code:"JR EAST E235-0", lines:"ì•¼ë§ˆë…¸í…Œì„ ", file:"/static/e235_0.json", lengths:[11]},
    {code:"JR EAST E235-1000", lines:"ìš”ì½”ìŠ¤ì¹´ì„ , ì†Œë¶€ ì¾Œì†ì„ , ë‚˜ë¦¬íƒ€ì„ , ìš°ì¹˜ë³´ì„ , ì†Œí† ë³´ì„ , ì¹´ì‹œë§ˆì„ , ì†Œë¶€ ë³¸ì„ , íŒì¹´ì¿ ì„ ", file:"/static/e235_1000.json", lengths:[4,11,15]}
  ],
  JRW223: [
    { code: "JR WEST 223-0",
      lines: "ì˜¤ì‚¬ì¹´ ìˆœí™˜ì„  Â· í•œì™€ì„  Â· ê°„ì‚¬ì´ê³µí•­ì„  ì§ê²° Â· ê¸°ë…¸ì¿ ë‹ˆì„ ",
      file: "/static/223_0000.json", lengths: [4] },
    { code: "JR WEST 223-1000",
      lines: "ë¹„ì™€ì½”Â·JR êµí† Â·JR ê³ ë²  ë¼ì¸ ë“±",
      file: "/static/223_1000.json", lengths: [4,8] }
  ],
  JRW225: [
    { code: "JR WEST 225-0",
      lines: "ë¹„ì™€ì½”Â·JR êµí† Â·JR ê³ ë²  ë¼ì¸ ë“±",
      file: "/static/225_0000.json", lengths: [4,8] },
    { code: "JR WEST 225-5000",
      lines: "ì˜¤ì‚¬ì¹´ ìˆœí™˜ì„  Â· í•œì™€ì„  Â· ê°„ì‚¬ì´ê³µí•­ì„ ",
      file: "/static/225_5000.json", lengths: [4] },
    { code: "JR WEST 225-6000",
      lines: "JR ê³ ë² ì„  Â· í›„ì¿ ì¹˜ì•¼ë§ˆì„ ",
      file: "/static/225_6000.json", lengths: [4,6] }
  ],
  JRW323: [{ code: "JR WEST 323-0", lines: "ì˜¤ì‚¬ì¹´ ìˆœí™˜ì„  ì „ìš©", file: "/static/323_0000.json", lengths: [8] }],
  JRW285: [{ code: "JR WEST 285-0/3000", lines: "ì¼ë°˜ ì¹¨ëŒ€íŠ¹ê¸‰ ì„ ë¼ì´ì¦ˆ ì´ì¦ˆëª¨Â·ì„¸í† ", file: "/static/285.json", lengths: [7, 14] }],
  JRH261: [{ code: "JR HOKKAIDO KiHa 261-5000", lines: "ë¶í•´ë„ì˜ í˜¹í•œì— ìµœì í™”ëœ íŠ¹ê¸‰ ë””ì ¤ë™ì°¨", file: "/static/261_5000.json", lengths: [4, 5, 6, 10] }],
JR103: [{
  code: "JR/JNR 103-0",
  lines: "1960~80ë…„ëŒ€ ì¼ë³¸ í†µê·¼í˜• ì „ë™ì°¨ì˜ ìƒì§•",
  file: "/static/103.json",
  lengths: [4, 6, 8, 10, 15]
}],
EF510: [{
  code: "JR EAST Cassiopeia â€¢ ì´ˆí˜¸í™” ì¹¨ëŒ€íŠ¹ê¸‰",
  lines: "ìš°ì—ë…¸â†”ì•„ì˜¤ëª¨ë¦¬",
  file: "/static/e26.json",
  lengths: [13]
}],
K3000: [{
  code: "Keisei 3000",
  lines: "ì¼€ì´ì„¸ì´ ë³¸ì„ , ë‚˜ë¦¬íƒ€ ê³µí•­ì„ ",
  file: "/static/keisei3000.json",
  lengths: [6, 8]
}],
T5300: [{
  code: "Toei 5300",
  lines: "ë„ì—ì´ ì•„ì‚¬ì¿ ì‚¬ì„ , ì¼€ì´ì„¸ì´ ë³¸ì„ , ê²Œì´í ë³¸ì„ ",
  file: "/static/toei5300.json",
  lengths: [8]
}],
N700S: [{
  code: "N700S-3000 H, Jí¸ì„±",
  lines: "ë„ì¹´ì´ë„ ì‹ ì¹¸ì„¼: ë„ì¿„â†”ì‹ ì˜¤ì‚¬ì¹´, ì‚°ìš” ì‹ ì¹¸ì„¼: ì‹ ì˜¤ì‚¬ì¹´â†”í•˜ì¹´íƒ€",
  file: "/static/n700s_3000.json",
  lengths: [16]
}]


};

const trainFamilyEl=document.getElementById('trainFamily');
const trainSeriesEl=document.getElementById('trainSeries');
const trainLengthEl=document.getElementById('trainLength');

function setTrainLengthOptions(lengths){
  trainLengthEl.innerHTML="";
  lengths.forEach(len=>{
    const opt=document.createElement('option');
    opt.value=String(len); opt.textContent=`${len}ëŸ‰`;
    trainLengthEl.appendChild(opt);
  });
  // updateTrainLength();
}
function loadVehicleFile(filePath){
  fetch(filePath + cacheBust(), { cache: 'no-store' })
    .then(res => res.json())
    .then(data => {
      vehicle = data;
      vehicle.notches = (vehicle.notch_accels || []).length;
      document.getElementById('carName').textContent = vehicle.name;

      brakeDecels = {};
      if (vehicle.notch_accels && vehicle.notches) {
        for (let i = 0; i < vehicle.notches; i++) {
          brakeDecels[i] = Math.abs(vehicle.notch_accels[vehicle.notches - 1 - i] ?? 0);
        }
      }

      if (ws.readyState === WebSocket.OPEN) {
        // ì„œë²„ì— ì°¨ëŸ‰ êµì²´(íŒŒì¼ëª…ë§Œ ê¶Œì¥)
        const justName = filePath.split('/').pop();
        ws.send(JSON.stringify({ type: "cmd", payload: { name: "setVehicleFile", file: justName } }));
        
        // ğŸ”’ ìˆœì„œ ë³´ì¥: ì§§ì€ ë§ˆì´í¬ë¡œ ë”œë ˆì´ ë’¤ ê¸¸ì´/íƒ‘ìŠ¹ë¥  ì „ì†¡
        // (WebSocket ACKê°€ ì—†ìœ¼ë‹ˆ ìµœì†Œí•œì˜ ìˆœì„œ ì•ˆì •í™”)
        const len = parseInt(document.getElementById("trainLength").value) || 8;
        const loadRate = parseFloat(document.getElementById("inputLoadRate").value) || 0;

        setTimeout(() => {
          ws.send(JSON.stringify({ type: "cmd", payload: { name: "setTrainLength", length: len } }));
          ws.send(JSON.stringify({ type: "cmd", payload: { name: "setLoadRate", loadRate, length: len } }));
        }, 10);
      }
    })
    .catch(console.error);
}


function populateSeries(){
  const fam = trainFamilyEl.value;
  const list = TRAIN_DB[fam] || [];
  trainSeriesEl.innerHTML = "";
  list.forEach((s,i)=>{
    const opt=document.createElement('option');
    opt.value=s.file; opt.dataset.lengths=JSON.stringify(s.lengths);
    opt.textContent=`${s.code} (${s.lines})`;
    if(i===0) opt.selected=true;
    trainSeriesEl.appendChild(opt);
  });

  if (list[0]) {
    // 1) UI ì˜µì…˜ë§Œ ì„¸íŒ… (ìë™ ì „ì†¡ X)
    setTrainLengthOptions(list[0].lengths);
    // 2) ì°¨ëŸ‰ ë¡œë“œ + ì„œë²„ ì „ì†¡ + ì´ì–´ì„œ ê¸¸ì´/íƒ‘ìŠ¹ë¥  ì „ì†¡
    loadVehicleFile(list[0].file);
  }
}

trainSeriesEl.addEventListener('change',(e)=>{
  const opt=e.target.selectedOptions[0];
  const lengths=JSON.parse(opt.dataset.lengths||"[]");
  // 1) ê¸¸ì´ ì˜µì…˜ë§Œ ë°”ê¿ˆ (ìë™ ì „ì†¡ X)
  setTrainLengthOptions(lengths);
  // 2) ì°¨ëŸ‰ ë¡œë“œ â†’ ì„œë²„ ì „ì†¡ â†’ ì´ì–´ì„œ ê¸¸ì´/íƒ‘ìŠ¹ë¥  ì „ì†¡
  loadVehicleFile(opt.value);
});
trainFamilyEl.addEventListener('change', populateSeries);
populateSeries(); // ìµœì´ˆ ì„¸íŒ…
</script>

<!-- ===== 10s ì–¸ì–´ í† ê¸€ (ko <-> en), í”¼ë“œë°± í¬í•¨ ===== -->
<script>


// ===== ì–¸ì–´ í† ê¸€ =====
(function(){
  const dict = {
    ko: {
      htmlLang: "ko",
      docTitle: "TASC Simulator",
      labelRemainTime: "ë‚¨ì€ì‹œê°„",
      labelSpeed: "ì†ë„",
      labelRemainDist: "ì •ì°¨",
      labelGrade: "êµ¬ë°°",
      labelNotch: "ë…¸ì¹˜",
      labelStartKey: "ì‹œì‘",
      labelUp: "ê°•í™”",
      labelDown: "ì™„í™”",
      labelRelease: "í•´ë°©",
      subtitleIntro: 
  "B1/B2ë‹¨ìœ¼ë¡œ ì œë™ì„ ì‹œì‘í•´ ë‚¨ì€ê±°ë¦¬ <b>150m</b> (P3 TASC ì§€ìƒì) ì§€ì ê¹Œì§€ ì†ë„ë¥¼ <b>60km/h</b> ì´í•˜ë¡œ ë‚®ì¶”ì„¸ìš”. ê·¸ ì´í›„ì—ëŠ” <b>TASC(ìë™ì •ì°¨)</b>ê°€ ìë™ìœ¼ë¡œ ì œë™ì„ ì´ì–´ë°›ìŠµë‹ˆë‹¤.",

      labelTASC: "TASC",
      labelTrain: "ì „ë™ì°¨",
      labelSeries: "ì‹œë¦¬ì¦ˆ",
      labelInitSpeed: "ì´ˆê¸° ì†ë„ (km/h)",
      labelInitDist: "ê±°ë¦¬ (m)",
      labelGradeInput: "ê²½ì‚¬ë„ (â€°)",
      labelWeather: "ë‚ ì”¨",
      labelLoadRate: "ìŠ¹ê° íƒ‘ìŠ¹ë¥  (%)",
      labelTrainLength: "í¸ì„±",
      btnStart: "Start (Space)",
      btnMobileRestart: "ì¬ì‹œì‘",
      feedback: {
        early_good: "ì´ˆê¸° ì œë™ì„ ìˆ˜í–‰í•¨ â€” ë¶€ë“œëŸ½ê²Œ ì œë™ ì§„ì…",
        early_bad: "ì´ˆê¸° ì œë™ì„ ê²Œì„ë¦¬í•¨ â€” ìŠ¹ì°¨ê° ë¶ˆì¾Œ",
        stop_good: "ì •ì°¨ ì‹œ B1ë¡œ ì •ì°¨í•¨ â€” ì •ì°¨ ì§ì „ ìŠ¹ì°¨ê° ì–‘í˜¸",
        stop_bad: "ì •ì°¨ ì‹œ B1ë¡œ ì •ì°¨í•˜ì§€ ì•ŠìŒ â€” ìŠ¹ì°¨ê° ë¶ˆì¾Œ",
        step_good: "ê¸°ë³¸ì œë™ (ê³„ë‹¨ì œë™/ì™„í•´) ìˆ˜í–‰í•¨",
        step_bad: "ê¸°ë³¸ì œë™ (ê³„ë‹¨ì œë™/ì™„í•´) ë¯¸í¡ â€” ë¶ˆê·œì¹™í•œ ì œë™ íŒ¨í„´ìœ¼ë¡œ ì¸í•œ ìŠ¹ì°¨ê° ë¶ˆì¾Œ",
        eb_good: "ì˜ì—… ì•ˆì „ ì œë™ë²”ìœ„ ì¤€ìˆ˜",
        eb_bad: "ë¶ˆí•„ìš”í•œ ë¹„ìƒì œë™(EB) ì‚¬ìš© â€” ê¸‰ê°ì† ì¶©ê²©",
        score: n=>`ìµœì¢… ì ìˆ˜: ${n}ì `,
        stopErr: m=>`ì •ì§€ ì˜¤ì°¨: ${m.toFixed(2)} m`,
         hintIdle: () => {
          const tips = [
            "íŒ: B1/B2ë¡œ ì†ë„ë¥¼ 60 km/h ì´í•˜ë¡œ ë‚®ì¶˜ ë’¤ í•´ë°©(Në‹¨)í•˜ì§€ ë§ê³  ë§ˆìŠ¤ì½˜ì„ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ì„¸ìš”.",
            "íŒ: TASC ì •ì°¨ í‘œì‹œë“±ì´ ì¼œì§€ë©´ TASCê°€ ìë™ ì œë™ì„ ì‹œì‘í–ˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.",
            "íŒ: TASC ì •ì°¨ í‘œì‹œë“±ì´ ê¹œë¹¡ì´ë©´, TASC ê°œì… ì „ì— ìˆ˜ë™ ì¡°ì‘ì´ ê°€ëŠ¥í•˜ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.",
            "íŒ: ì—´ì°¨ê°€ ì •ìœ„ì¹˜ì— ë„ë‹¬í•˜ë©´ TASC ì •ìœ„ì¹˜ í‘œì‹œë“±ì´ ì¼œì§‘ë‹ˆë‹¤.",
            "íŒ: ë‚¨ì€ ê±°ë¦¬ë¥¼ í™•ì¸í•˜ë©° ì—¬ìœ  ìˆê²Œ B1ìœ¼ë¡œ ì •ì°¨í•˜ì—¬ ìŠ¹ì°¨ê°ì„ í™•ë³´í•˜ì„¸ìš”.",
            "íŒ: Aí‚¤ëŠ” 6ë‹¨(í˜¹ì€ 5ë‹¨) ì œë™, Dí‚¤ëŠ” B1 ì œë™, Eí‚¤ëŠ” ë¹„ìƒì œë™ì„ ë°œë™ì‹œí‚µë‹ˆë‹¤.",
            "íŒ: Qí‚¤ëŠ” ìµœëŒ€ ìƒìš© ê°€ì†ì„ ë°œë™ì‹œí‚µë‹ˆë‹¤.",
            "íŒ: ì •ì°¨ ì§ì „ ë§ˆìŠ¤ì½˜ì„ í’€ì—ˆë‹¤ ë‹¤ì‹œ ì¡°ì‘í•˜ëŠ” ì¼ëª… \"í†±ì§ˆ\" í–‰ìœ„ëŠ” ìŠ¹ì°¨ê°ì„ í¬ê²Œ ì €í•˜ì‹œí‚µë‹ˆë‹¤.",
            "íŒ: ì •ì°¨ ë„ì¤‘ ì—­í–‰(ì¬ê°€ì†) ì·¨ê¸‰ì€ ì ˆëŒ€ ê¸ˆë¬¼ì…ë‹ˆë‹¤."
          ];

          return tips[Math.floor(Math.random() * tips.length)];
        },
        hintAgain: "Spaceë¡œ ë‹¤ì‹œ ì‹œì‘ Â· N í•´ë°© Â· W/Së¡œ ì¡°ì‘"
      }
    },
    en: {
      htmlLang: "en",
      docTitle: "TASC Simulator",
      labelRemainTime: "STA",
      labelSpeed: "Speed",
      labelRemainDist: "Distance",
      labelGrade: "Grade",
      labelNotch: "Notch",
      labelStartKey: "Start",
      labelUp: "B+",
      labelDown: "B-",
      labelRelease: "Release",
      subtitleIntro: 
  "Begin braking with B1/B2 and reduce speed to below <b>60km/h</b> by <b>150m</b> remaining (P3 TASC beacon). After that, <b>TASC (Autopilot)</b> takes over brake control.",


      labelTASC: "TASC",
      labelTrain: "Train",
      labelSeries: "Series",
      labelInitSpeed: "Initial Speed (km/h)",
      labelInitDist: "Distance (m)",
      labelGradeInput: "Grade (â€°)",
      labelWeather: "Weather",
      labelLoadRate: "Passenger Load (%)",
      labelTrainLength: "Formation",
      btnStart: "Start (Space)",
      btnMobileRestart: "Restart",
      feedback: {
  early_good: "You braked early â€” smooth initial deceleration",
  early_bad: "You braked late â€” the ride felt rough",
  stop_good: "Stopped at B1 â€” smooth ride just before stopping",
  stop_bad: "Failed to stop at B1 â€” the ride felt rough",
  step_good: "Stepwise braking was applied correctly",
  step_bad: "Stepwise braking was poor, causing jolts and discomfort for passengers",
  eb_good: "Safe braking range observed â€” no EB applied",
  eb_bad: "Unnecessary EB applied, causing a harsh jolt",
  score: n => `Final score: ${n}`,
  stopErr: m => `Stopping error: ${m.toFixed(2)} m`,
  hintIdle: () => {
    const tips = [
      "Tip: Reduce speed below 60 km/h with B1/B2 and keep the master controller in place (do not release with N).",
      "Tip: If the TASC stop indicator lights up, it means TASC has started automatic braking.",
      "Tip: If the TASC stop indicator flashes, you can manually intervene before TASC takes over.",
      "Tip: When the train reaches the exact stop position, the TASC stop-position indicator will light up.",
      "Tip: Press A for the recommended maximum service brake, D for B1 brake, and E for emergency brake.",
      "Tip: Press Q for maximum acceleration.",
      "Tip: Check the remaining distance and stop gently with B1 to ensure a smooth ride.",
      "Tip: Reapplying and releasing the master controller just before stopping can severely affect ride comfort.",
      "Tip: Never consider re-acceleration while bringing the train to a stop."

    ];

    return tips[Math.floor(Math.random() * tips.length)];
  },

  hintAgain: "Press Space to restart, N to release, W/S to brake."
}
    }
  };

  const nodes = {
    labelRemainTime: document.getElementById("labelRemainTime"),
    labelSpeed: document.getElementById("labelSpeed"),
    labelRemainDist: document.getElementById("labelRemainDist"),
    labelGrade: document.getElementById("labelGrade"),
    labelNotch: document.getElementById("labelNotch"),
    subtitleIntro: document.getElementById("subtitleIntro"),
    labelTASC: document.getElementById("labelTASC"),
    labelTrain: document.getElementById("labelTrain"),
    labelSeries: document.getElementById("labelSeries"),
    labelInitSpeed: document.getElementById("labelInitSpeed"),
    labelInitDist: document.getElementById("labelInitDist"),
    labelGradeInput: document.getElementById("labelGradeInput"),
    labelWeather: document.getElementById("labelWeather"),
    labelLoadRate: document.getElementById("labelLoadRate"),
    labelTrainLength: document.getElementById("labelTrainLength"),
    btnStart: document.getElementById("btnStart"),
    btnMobileRestart: document.getElementById("btnMobileRestart"),
    fb: document.getElementById("fb")
  };

  function setLang(lang){
    const d = dict[lang];
    document.documentElement.lang = d.htmlLang;
    document.title = d.docTitle;

    [
      "labelRemainTime","labelSpeed","labelRemainDist","labelGrade","labelNotch",
      "labelStartKey","labelUp","labelDown","labelRelease",
      "labelTASC","labelTrain","labelSeries","labelInitSpeed","labelInitDist",
      "labelGradeInput","labelWeather","labelLoadRate","labelTrainLength"
    ].forEach(k => { if(nodes[k]) nodes[k].innerText = d[k]; });

    if(nodes.subtitleIntro) nodes.subtitleIntro.innerHTML = d.subtitleIntro;
    if(nodes.btnStart) nodes.btnStart.textContent = d.btnStart;
    if(nodes.btnMobileRestart) nodes.btnMobileRestart.textContent = d.btnMobileRestart;

    // ---- í”¼ë“œë°± ë²ˆì—­ ----
    if (nodes.fb) {
      const fbd = d.feedback;
      const st = window.st;
      if (st && st.finished) {
        const issues = st.issues ?? {};
        let rows = [];
        rows.push({ bad: !!issues.early_brake_too_short, goodText: fbd.early_good, badText: fbd.early_bad });
        rows.push({ bad: !!issues.stop_not_b1,           goodText: fbd.stop_good,  badText: fbd.stop_bad  });
        rows.push({ bad: !!issues.step_brake_incomplete, goodText: fbd.step_good,  badText: fbd.step_bad  });
        rows.push({ bad: !!issues.unnecessary_eb_usage,  goodText: fbd.eb_good,    badText: fbd.eb_bad    });

        let html = rows.map(r =>
          `<div class="${r.bad ? "bad" : "ok"}">${r.bad ? r.badText : r.goodText}</div>`
        ).join("");

        const stopErr = Number(st.stop_error_m ?? 0);
        const score   = Number(st.score ?? 0);
        const goodErr = Math.abs(stopErr) <= 2;

        html += `<div class="${goodErr ? "ok" : "warn"}">${fbd.stopErr(stopErr)}</div>`;
        html += `<div class="${goodErr ? "ok" : "warn"}">${fbd.score(score)}</div>`;
        html += `<div style="margin-top:8px;font-size:12px;color:#a6b7d1">${fbd.hintAgain}</div>`;
        nodes.fb.innerHTML = html;
      } else {
        nodes.fb.textContent = fbd.hintIdle();
      }
    }
  }

  // ===== 5ì´ˆë§ˆë‹¤ í† ê¸€ =====
  let current = "ko";
  setLang(current);
  setInterval(()=>{
    current = (current==="ko") ? "en" : "ko";
    setLang(current);
  }, 10000);
})();

</script>

<footer style="text-align:center; font-size:12px; color:#888; padding:8px 0; user-select:none;">
  Â©2025 Hyungsuk Choi, University of Maryland
</footer>
</body>
</html>